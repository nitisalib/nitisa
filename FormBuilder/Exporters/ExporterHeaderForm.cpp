// This file is a part of Nitisa framework
// Copyright © 2022 Nitisa. All rights reserved.
// Author: Dimitry Lysenko
// Site: http://nitisa.com
// Download: http://nitisa.com/downloads
// Documentation: http://nitisa.com/documentation
// License: http://nitisa.com/site/license

#include "stdafx.h"

namespace nitisa
{
	namespace fb
	{
	#pragma region Constructor & destructor
		CExporterHeaderForm::CExporterHeaderForm() : CBaseExporter()
		{

		}
	#pragma endregion

	#pragma region Interface getters
		String CExporterHeaderForm::getName() const
		{
			return L"C++ form prototype";
		}

		String CExporterHeaderForm::getDescription() const
		{
			return L"Export form prototype into C++ header file";
		}
	#pragma endregion

	#pragma region Export
		bool CExporterHeaderForm::Export(const String &filename, const EXPORT_SETTINGS &settings, CComponentList *components, CControlList *controls, Form &form, const String &ver, IControl *parent)
		{
			m_eLastError = ErrorType::None;
			std::wofstream f{ filename };
			if (f.bad())
			{
				m_eLastError = ErrorType::FileOpen;
				return false;
			}
			StringArray includes;
			OverwriteNamespaces(settings.OverwriteNamespaces);
			
			String shift{ settings.Namespace.empty() ? L"" : L"\t" };
			const std::locale utf8_locale{ std::locale(std::locale(), new std::codecvt_utf8<wchar_t>()) };
			f.imbue(utf8_locale);
			ExportLicense(f, settings, ver, form.Name);
			f << std::endl;
			f << L"#pragma once" << std::endl;
			f << std::endl;
			ExportIncludes(f, components, controls, form, settings, includes);
			f << L"namespace nitisa" << std::endl;
			f << L"{" << std::endl;
			ExportForwardDeclarations(f, components, controls, form, settings, includes);
			if (!settings.Namespace.empty())
			{
				f << L"\tnamespace " << settings.Namespace << std::endl;
				f << L"\t{" << std::endl;
			}
			f << shift << L"\tclass I" << form.Name << L" : public CForm" << std::endl;
			f << shift << L"\t{" << std::endl;
			f << shift << L"\t" << settings.WidgetsSection << L":" << std::endl;
			ExportComponentDeclarations(f, shift, components, settings.Prefix);
			ExportControlDeclarations(f, shift, controls, settings.Prefix);
			ExportEventDeclarations(f, shift, components, controls, form.Events, settings.OverwriteNamespaces);
			f << shift << L"\tprivate:" << std::endl;
			ExportInitialize(f, shift, components, controls, parent, settings.Prefix, form.Name);
			f << shift << L"\tpublic:" << std::endl;
			f << shift << L"\t\tI" + form.Name + L"(IWindow *window, IRenderer *renderer, const String &class_name = L\"" << form.Name << L"\", const CreateParams *params = nullptr) :" << std::endl;
			f << shift << L"\t\t\tCForm(class_name, nullptr, renderer, params)";
			ExportDefaultValues(f, shift, components, controls, settings.Prefix);
			f << std::endl;
			f << shift << L"\t\t{" << std::endl;
			f << shift << L"\t\t\tif (window)" << std::endl;
			f << shift << L"\t\t\t{" << std::endl;
			f << shift << L"\t\t\t\tCLockRepaint lock(this);" << std::endl;
			IPropertyIdentifier *property_name{ cast<IPropertyIdentifier*>(form.Properties->getProperty(L"Name")) };
			if (property_name && property_name->getValue().find(L"{type}") != String::npos)
			{
				String old{ property_name->getValue() };
				property_name->setValue(PrepareFormName(old));
				form.Properties->Export(f, L"\t\t\t" + shift, L"");
				property_name->setValue(old);
			}
			else
				form.Properties->Export(f, L"\t\t\t\t" + shift, L"");
			ExportComponentsExtra(f, L"\t\t\t\t" + shift, components);
			ExportControlsExtra(f, L"\t\t\t\t" + shift, controls);
			f << shift << L"\t\t\t\tQueryService()->setWindow(window);" << std::endl;
			f << shift << L"\t\t\t\tApplication->QueryService()->Add(this);" << std::endl;
			f << shift << L"\t\t\t\tInitialize();" << std::endl;
			f << shift << L"\t\t\t\tRepaint(Rect{ 0, 0, 0, 0 }, true);" << std::endl;
			form.Events->Export(f, L"\t\t\t\t" + shift, L"", form.Name, L"");
			f << shift << L"\t\t\t}" << std::endl;
			f << shift << L"\t\t}" << std::endl;
			if (settings.GenerateGetters)
				ExportGetters(f, shift + L"\t\t", components, controls, settings.Prefix);
			f << shift << L"\t};" << std::endl;
			if (!settings.Namespace.empty())
				f << L"\t}" << std::endl;
			f << L"}" << std::endl;
			f.close();

			RestoreNamespaces(settings.OverwriteNamespaces);
			return true;
		}

		void CExporterHeaderForm::ExportLicense(std::wofstream &f, const EXPORT_SETTINGS &settings, const String &ver, const String &form_name)
		{
			f << L"// This file was generated by Form Builder from Nitisa C++ GUI framework" << std::endl;
			f << L"// Framework site: http://nitisa.com" << std::endl;
			f << L"// Framework download: http://nitisa.com/downloads" << std::endl;
			f << L"// Framework documentation: http://nitisa.com/documentation" << std::endl;
			f << L"// Framework license: http://nitisa.com/site/license" << std::endl;
			f << L"// Form Builder version: " << ver << std::endl;
			f << L"// Form Builder documentation: http://nitisa.com/guide/form-builder" << std::endl;
			f << L"// Generated: " << CDateTime{} << std::endl;
			f << std::endl;

			String shift, ns1, ns2;
			if (!settings.Namespace.empty())
			{
				shift += L"    ";
				ns1 = L"//             namespace " + settings.Namespace + L"\n//             {\n";
				ns2 = L"//             }\n";
			}
			f << L"// !!! ATTENTION !!!" << std::endl;
			f << L"// This is an auto-generated file with form declaration and initialization." << std::endl;
			f << L"// Include it into your form class header file and derive your form from the class implemented here." << std::endl;
			f << L"// Add constructor and implement event processing methods(if exist) from \"protected\" section." << std::endl;

			f << L"// For example:" << std::endl;
			f << L"//     " << form_name << L".h:" << std::endl;
			f << L"//         #include \"I" << form_name << L".h\" // Include this file" << std::endl;
			f << L"//" << std::endl;
			f << L"//         namespace nitisa" << std::endl;
			f << L"//         {" << std::endl;
			f << L"//             class IControl;" << std::endl;
			f << L"//" << std::endl;
			f << ns1;
			f << L"//             " << shift << L"class C" << form_name << L" : public I" << form_name << L" // Derive your form from class from this file" << std::endl;
			f << L"//             " << shift << L"{" << std::endl;
			f << L"//             " << shift << L"protected: // Declare overridden methods handling events if there ones in this class" << std::endl;
			f << L"//             " << shift << L"    void ButtonAdd_OnClick(IControl *sender) override;" << std::endl;
			f << L"//             " << shift << L"public:" << std::endl;
			f << L"//             " << shift << L"    C" << form_name << L"(); // Declare constructor" << std::endl;
			f << L"//             " << shift << L"};" << std::endl;
			f << ns2;
			f << L"//         }" << std::endl;
			f << L"//" << std::endl;

			f << L"//     " << form_name << L".cpp:" << std::endl;
			f << L"//         #include \"Standard/Platform/Windows/Window.h\" // Include required platform window management class" << std::endl;
			f << L"//         #include \"Standard/Platform/Windows/OpenGL/Renderer.h\" // Include required renderer" << std::endl;
			f << L"//         #include \"" << form_name << L".h\" // Include header class of your form" << std::endl;
			f << L"//" << std::endl;
			f << L"//         namespace nitisa" << std::endl;
			f << L"//         {" << std::endl;
			f << ns1;
			f << L"//             " << shift << L"C" << form_name << L"::C" << form_name << L"(): // Implement constructor of your form" << std::endl;
			f << L"//             " << shift << L"    I" << form_name << L"(new standard::windows::CWindow(), new standard::windows::opengl::CRenderer(false, 0))" << std::endl;
			f << L"//             " << shift << L"{" << std::endl;
			f << L"//             " << shift << L"    // Insert your code here" << std::endl;
			f << L"//             " << shift << L"}" << std::endl;
			f << L"//" << std::endl;
			f << L"//             " << shift << L"void C" << form_name << L"::ButtonAdd_OnClick(IControl *sender) // Implement event processing methods" << std::endl;
			f << L"//             " << shift << L"{" << std::endl;
			f << L"//             " << shift << L"    // Insert your code here" << std::endl;
			f << L"//             " << shift << L"}" << std::endl;
			f << ns2;
			f << L"//         }" << std::endl;
			f << std::endl;
		}

		void CExporterHeaderForm::ExportInitialize(std::wofstream &f, const String &shift, CComponentList *components, CControlList *controls, IControl *parent, const String &prefix, const String &form_name)
		{
			f << shift << L"\t\tvoid Initialize()" << std::endl;
			f << shift << L"\t\t{" << std::endl;
			ExportComponentsCreationInitialize(f, shift, components, prefix, L"this");
			if (parent->getControlCount() > 0)
			{
				f << shift << L"\t\t\t// Create controls" << std::endl;
				ExportControlsCreationInitialize(f, parent, L"this", shift, prefix, controls);
				f << std::endl;
			}
			ExportComponentsInitialize(f, shift, components, prefix, form_name);
			if (parent->getControlCount() > 0)
			{
				f << shift << L"\t\t\t// Initialize controls" << std::endl;
				ExportControlsInitialize(f, parent, shift, controls, prefix, form_name);
				f << std::endl;
			}
			f << shift << L"\t\t}" << std::endl;
			f << std::endl;
		}

		void CExporterHeaderForm::ExportComponentsInitialize(std::wofstream &f, const String &shift, CComponentList *components, const String &prefix, const String &form_name)
		{
			if (components->getCount() > 0)
			{
				f << shift << L"\t\t\t// Initialize components" << std::endl;
				for (int i = 0; i < components->getCount(); i++)
				{
					COMPONENT_INFO *info{ components->getInfo(i) };
					info->PackageComponent->Export(f, L"\t\t\t" + shift, prefix + info->Component->Name, info->Properties, info->Events, form_name, L"");
					f << std::endl;
				}
			}
		}

		void CExporterHeaderForm::ExportControlsInitialize(std::wofstream &f, IControl *parent, const String &shift, CControlList *controls, const String &prefix, const String &form_name)
		{
			for (int i = 0; i < parent->getControlCount(); i++)
			{
				CONTROL_INFO *info{ controls->getInfo(parent->getControl(i)) };
				info->PackageControl->Export(f, L"\t\t\t" + shift, prefix + info->Control->Name, info->Properties, info->Events, form_name, L"");
				f << std::endl;
				ExportControlsInitialize(f, info->Control, shift, controls, prefix, form_name);
			}
		}

		String CExporterHeaderForm::PrepareFormName(const String &name)
		{
			return Replace(name, L"{type}", L"Form");
		}
	#pragma endregion
	}
}