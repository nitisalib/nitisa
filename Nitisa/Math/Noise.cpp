// This file is a part of Nitisa framework
// Copyright © 2020 Nitisa. All rights reserved.
// Author: Dimitry Lysenko
// Site: http://nitisa.com
// Download: http://nitisa.com/downloads
// Documentation: http://nitisa.com/documentation
// License: http://nitisa.com/site/license

#include "stdafx.h"

namespace nitisa
{
#pragma region Constants
	const int X_PRIME{ 1619 };
	const int Y_PRIME{ 31337 };
	const int Z_PRIME{ 6971 };
	const int W_PRIME{ 1013 };
	const double F3{ 1 / 3.0 };
	const double G3{ 1 / 6.0 };
	const double SQRT3{ 1.7320508075688772935274463415059 };
	const double F2{ 0.5 * (SQRT3 - 1.0) };
	const double G2{ (3.0 - SQRT3) / 6.0 };
	const double F4{ (std::sqrt(5.0) - 1) / 4.0 };
	const double G4{ (5 - std::sqrt(5.0)) / 20.0 };
	const double CUBIC_3D_BOUNDING{ 1 / (1.5 * 1.5 * 1.5) };
	const double CUBIC_2D_BOUNDING{ 1 / (1.5 * 1.5) };

	const double GRAD_X[] =
	{
			1, -1,  1, -1,
			1, -1,  1, -1,
			0,  0,  0,  0
	};

	const double GRAD_Y[] =
	{
			1,  1, -1, -1,
			0,  0,  0,  0,
			1, -1,  1, -1
	};

	const double GRAD_Z[] =
	{
			0,  0,  0,  0,
			1,  1, -1, -1,
			1,  1, -1, -1
	};

	const double GRAD_4D[] =
	{
		 0,  1,  1,  1,  0,  1,  1, -1,  0,  1, -1,  1,  0,  1, -1, -1,
		 0, -1,  1,  1,  0, -1,  1, -1,  0, -1, -1,  1,  0, -1, -1, -1,
		 1,  0,  1,  1,  1,  0,  1, -1,  1,  0, -1,  1,  1,  0, -1, -1,
		-1,  0,  1,  1, -1,  0,  1, -1, -1,  0, -1,  1, -1,  0, -1, -1,
		 1,  1,  0,  1,  1,  1,  0, -1,  1, -1,  0,  1,  1, -1,  0, -1,
		-1,  1,  0,  1, -1,  1,  0, -1, -1, -1,  0,  1, -1, -1,  0, -1,
		 1,  1,  1,  0,  1,  1, -1,  0,  1, -1,  1,  0,  1, -1, -1,  0,
		-1,  1,  1,  0, -1,  1, -1,  0, -1, -1,  1,  0, -1, -1, -1,  0
	};

	const double VAL_LUT[] =
	{
		 0.34901960780,  0.43529411760, -0.45098039220,  0.6392156863,  0.584313725500, -0.121568627500,  0.71764705880, -0.1058823529,  0.39607843140,  0.0431372549, -0.03529411765,  0.31764705880,  0.72549019610,  0.1372549020,  0.85882352940, -0.81960784310,
		-0.79607843140, -0.33333333330, -0.67058823530, -0.3882352941,  0.262745098000,  0.325490196100, -0.64705882350, -0.9215686275, -0.52941176470,  0.5294117647, -0.46666666670,  0.81176470590,  0.38039215690,  0.6627450980,  0.03529411765, -0.61568627450,
		-0.01960784314, -0.35686274510, -0.09019607843,  0.7490196078,  0.835294117600, -0.403921568600, -0.74901960780,  0.9529411765, -0.04313725490, -0.9294117647, -0.65490196080,  0.92156862750, -0.06666666667, -0.4431372549,  0.41176470590, -0.41960784310,
		-0.71764705880, -0.81176470590, -0.25490196080,  0.4901960784,  0.913725490200,  0.788235294100, -1.00000000000, -0.4745098039,  0.79607843140,  0.8509803922, -0.67843137250,  0.45882352940,  1.00000000000, -0.1843137255,  0.45098039220,  0.14509803920,
		-0.23137254900, -0.96862745100, -0.85882352940,  0.4274509804,  0.003921568627, -0.003921568627,  0.21568627450,  0.5058823529,  0.76470588240,  0.2078431373, -0.59215686270,  0.57647058820, -0.19215686270, -0.9372549020,  0.08235294118, -0.08235294118,
		 0.90588235290,  0.82745098040,  0.02745098039, -0.1686274510, -0.780392156900,  0.113725490200, -0.94509803920,  0.2000000000,  0.01960784314,  0.5607843137,  0.27058823530,  0.44313725490, -0.96078431370,  0.6156862745,  0.92941176470, -0.07450980392,
		 0.30980392160,  0.99215686270, -0.91372549020, -0.2941176471, -0.341176470600, -0.623529411800, -0.76470588240, -0.8901960784,  0.05882352941,  0.2392156863,  0.73333333330,  0.65490196080,  0.24705882350,  0.2313725490, -0.39607843140, -0.05098039216,
		-0.22352941180, -0.37254901960,  0.62352941180,  0.7019607843, -0.827450980400,  0.419607843100,  0.07450980392,  0.8666666667, -0.53725490200, -0.5058823529, -0.80392156860,  0.09019607843, -0.48235294120,  0.6705882353, -0.78823529410,  0.09803921569,
		-0.60784313730,  0.80392156860, -0.60000000000, -0.3254901961, -0.411764705900, -0.011764705880,  0.48235294120,  0.1686274510,  0.87450980390, -0.3647058824, -0.16078431370,  0.56862745100, -0.99215686270,  0.9450980392,  0.51372549020,  0.01176470588,
		-0.14509803920, -0.55294117650, -0.57647058820, -0.1137254902,  0.521568627500,  0.160784313700,  0.37254901960, -0.2000000000, -0.72549019610,  0.6313725490,  0.70980392160, -0.56862745100,  0.12941176470, -0.3098039216,  0.74117647060, -0.85098039220,
		 0.25490196080, -0.63921568630, -0.56078431370, -0.3176470588,  0.937254902000,  0.984313725500,  0.59215686270,  0.6941176471,  0.28627450980, -0.5215686275,  0.17647058820,  0.53725490200, -0.49019607840, -0.4588235294, -0.20784313730, -0.21568627450,
		 0.77254901960,  0.36470588240, -0.23921568630,  0.2784313725, -0.882352941200,  0.898039215700,  0.12156862750,  0.1058823529, -0.87450980390, -0.9843137255, -0.70196078430,  0.96078431370,  0.29411764710,  0.3411764706,  0.15294117650,  0.06666666667,
		-0.97647058820,  0.30196078430,  0.64705882350, -0.5843137255,  0.050980392160, -0.513725490200, -0.13725490200,  0.3882352941, -0.26274509800, -0.3019607843, -0.17647058820, -0.75686274510,  0.18431372550, -0.5450980392, -0.49803921570, -0.27843137250,
		-0.95294117650, -0.09803921569,  0.89019607840, -0.2862745098, -0.380392156900,  0.552941176500,  0.78039215690, -0.8352941176,  0.68627450980,  0.7568627451,  0.49803921570, -0.68627450980, -0.89803921570, -0.7725490196, -0.70980392160, -0.24705882350,
		-0.90588235290,  0.97647058820,  0.19215686270,  0.8431372549, -0.058823529410,  0.356862745100,  0.60784313730,  0.5450980392,  0.40392156860, -0.7333333333, -0.42745098040,  0.60000000000,  0.67843137250, -0.6313725490, -0.02745098039, -0.12941176470,
		 0.33333333330, -0.84313725490,  0.22352941180, -0.3490196078, -0.694117647100,  0.882352941200,  0.47450980390,  0.4666666667, -0.74117647060, -0.2705882353,  0.96862745100,  0.81960784310, -0.66274509800, -0.4352941176, -0.86666666670, -0.15294117650,
	};

	const double CELL_2D_X[] =
	{
		-0.6440658039, -0.08028078721,  0.99835461680,  0.9869492062,  0.92847464180,  0.6051097552, -0.7941674040, -0.34886679910, -0.94313652600, -0.99681713180,  0.87409615790,  0.14211397640,  0.4282553608, -0.9986665833,  0.9996760121, -0.06248383632,
		 0.7120139305,  0.89176604090,  0.10948429550, -0.8730880804,  0.25948114890, -0.6690063346, -0.9996834972, -0.88036086710, -0.81665549370,  0.89555996760, -0.93983213880,  0.07615451399, -0.7147270565,  0.8707354457, -0.9580008579,  0.49059656320,
		 0.7867759440,  0.10797115770,  0.26866389790,  0.6113487322, -0.53077058400, -0.7837268286, -0.8558691039, -0.57260938960, -0.98307409140,  0.70877663590,  0.68070271530, -0.08864708788,  0.6704485923, -0.1350735482, -0.9381333003,  0.97566553760,
		 0.4231433671, -0.49597873850,  0.10055543250, -0.7645857281, -0.58590537960, -0.9751154306, -0.6972258572,  0.79070120020, -0.91098992130, -0.95843078940, -0.82695293330,  0.26082647190, -0.7773760119,  0.7606456974, -0.8961083758, -0.98381347190,
		 0.7338893576,  0.21612267290,  0.67350989100, -0.5512056873,  0.68997443320,  0.8680048310,  0.5897430311, -0.89504442210, -0.35957527730,  0.82094869810, -0.29123601320, -0.99650113740,  0.9766994634,  0.7387908220, -0.4730947722,  0.89464794410,
		-0.6943628971, -0.66204681820, -0.08872555020, -0.7512250855, -0.53229868980,  0.5226295385,  0.2296318375,  0.79153073440, -0.27564859990, -0.69002345220,  0.07090588086,  0.59812784850,  0.3033429312, -0.7253142797, -0.9855874307, -0.17618433960,
		-0.6438468325, -0.99561365950,  0.85415807620, -0.9999807666, -0.02152416253, -0.8705983095, -0.1197138014, -0.99210778100, -0.90911815460,  0.78861053600, -0.99463640200,  0.42112568530,  0.3110430857, -0.4031127839,  0.7610684239,  0.76856744670,
		 0.1522715550, -0.93646487230,  0.16813337390, -0.3567427907, -0.41844548300, -0.9877477800,  0.8705250765, -0.89117010670, -0.73153509660,  0.60308856580, -0.41491308210,  0.75853394810,  0.6963196535,  0.8332685012, -0.8086815232,  0.75181167240,
		-0.3490535894,  0.69721109030, -0.87956769280, -0.6442331882,  0.66102368110, -0.9853565782, -0.5903384580,  0.09843602117,  0.56465348820, -0.60232592330, -0.35392488610,  0.51327286560,  0.9380385118, -0.7599270056, -0.7425936564, -0.66796105620,
		-0.3018497816,  0.81447826600,  0.03777430269, -0.7514235086,  0.96625569390, -0.4720194901, -0.4350541260,  0.70919012350,  0.92937920900,  0.99974343570,  0.83063202990, -0.94340196290, -0.1331337590,  0.5048413216,  0.3711995273,  0.98552091000,
		 0.7401857005, -0.99999813980, -0.21440332530,  0.4808624681, -0.41383588500,  0.6442293050,  0.9626648696,  0.18336659340,  0.57941290000,  0.01404446873,  0.43884949930,  0.52136123220, -0.5281609948, -0.9745306846, -0.9904373013,  0.91002322520,
		-0.9914057719,  0.78926277650,  0.33644216590, -0.9416099764,  0.78027326560,  0.8863028710,  0.6524471291,  0.57621867260, -0.08987644664, -0.21770267820, -0.97203450520, -0.05722538858,  0.8105983127,  0.3410261032,  0.6452309645, -0.78106121520,
		 0.9989395718, -0.80824781500,  0.63701779290,  0.5844658772,  0.20540708610,  0.0559605220, -0.9958275610,  0.89340916500, -0.93151682400,  0.32896946900, -0.31938374880,  0.73147556570, -0.7913517714, -0.2204109786,  0.9955900414, -0.71123531390,
		-0.7935008741, -0.99619182040, -0.97141639950, -0.9566188669,  0.27484956320, -0.4681743221, -0.9614449642,  0.58519407200,  0.45329460610, -0.99161131760,  0.94247958700, -0.98137047530, -0.6538429571,  0.2923335053, -0.2246660704, -0.18007819490,
		-0.9581216256,  0.55221508200, -0.92967919220,  0.6431836990,  0.99973259810, -0.4606920354, -0.2148721265,  0.34820708090,  0.30755178130,  0.62747563930,  0.89108817650, -0.63977713090, -0.4479080125, -0.5247665011, -0.8386507094,  0.39012914160,
		 0.1458336921,  0.01624613149, -0.82731998790,  0.5611100679, -0.83802198410, -0.9856122234, -0.8613986180,  0.63984139160,  0.26945107950,  0.43273345140, -0.99602653540, -0.93957065500, -0.8846996446,  0.7642113189, -0.7002080528,  0.66450825600,
	};

	const double CELL_2D_Y[] =
	{
		 0.76497009110,  0.996772288500,  0.05734160033, -0.161031874100,  0.37139579900, -0.7961420628,  0.60769904920, -0.9371723195,  0.3324056156,  0.07972205329, -0.48575292770, -0.98985030070,  0.9036577593,  0.05162417479, -0.02545330525, -0.9980459760,
		-0.70216533860, -0.452496771700, -0.99398852560, -0.487562512800, -0.96574817290, -0.7432567015,  0.02515761212,  0.4743044842,  0.5771254669,  0.44494083240,  0.34163657730,  0.99709602850,  0.6994034849,  0.49175174990,  0.28676533300,  0.8713868327,
		 0.61723870090,  0.994154026900,  0.96323398510, -0.791361312900,  0.84751553800,  0.6211056739,  0.51719249520, -0.8198283277, -0.1832084353,  0.70543297370,  0.73255976780,  0.99606309730,  0.7419559859,  0.99083557490, -0.34627432900,  0.2192641299,
		-0.90606274110, -0.868334665300,  0.99493145740, -0.644522043300, -0.81037947040, -0.2216977607,  0.71685152170,  0.6122022640, -0.4124286160,  0.28532511600,  0.56227115000, -0.96538570090, -0.6290361962,  0.64916725350,  0.44383530600, -0.1791955706,
		-0.67926902690, -0.976366217300,  0.73917821040,  0.834369396800,  0.72383373890,  0.4965557504,  0.80759095920, -0.4459769977, -0.9331160806, -0.57100195720,  0.95665123460, -0.08357920318,  0.2146116448, -0.67393480490,  0.88101154170,  0.4467718167,
		-0.71962501840, -0.749462481000,  0.99605611120,  0.660046112700, -0.84655661640, -0.8525598897, -0.97327756540,  0.6111293616, -0.9612584717, -0.72378700970, -0.99748301040, -0.80140069680,  0.9528814544, -0.68841789310, -0.16916683010,  0.9843571905,
		 0.76515440030, -0.093559826050, -0.52001344290, -0.006202125807, -0.99976832840,  0.4919944954, -0.99280844360, -0.1253880012, -0.4165383308, -0.61489301710, -0.10343320490, -0.90700229170, -0.9503958117,  0.91515030650, -0.64867160730,  0.6397687707,
		-0.98833869370,  0.350761376100,  0.98576425610, -0.934202644600, -0.90824191590,  0.1560587169,  0.49212406070, -0.4536693080,  0.6818037859,  0.79767423290,  0.90986105220,  0.65163352400,  0.7177318024, -0.55286852410,  0.58824671180,  0.6593778956,
		 0.93710276480, -0.716865883900, -0.47577376320,  0.764829130700,  0.75036503980,  0.1705063456, -0.80715581210, -0.9951433815, -0.8253280792, -0.79825026280,  0.93527385030,  0.85822547470, -0.3465310238,  0.65000842000, -0.66974223510,  0.7441962291,
		-0.95335550000,  0.580194065900, -0.99928629630, -0.659820211000,  0.25758480920,  0.8815881130, -0.90040430220, -0.7050172826,  0.3691263820, -0.02265088836,  0.55682172280, -0.33165152860,  0.9910980790, -0.86321216400, -0.92855312770,  0.1695539323,
		-0.67240250500, -0.001928841934,  0.97674521450, -0.876796034900,  0.91035150370, -0.7648324016,  0.27069604520, -0.9830446035,  0.8150341657, -0.99990137160, -0.89856058060,  0.85333608010,  0.8491442537, -0.22425419660, -0.13796358990, -0.4145572694,
		 0.13082276330,  0.614055591600,  0.94170413030, -0.336705587000, -0.62543875080,  0.4631060578, -0.75783424560, -0.8172955655, -0.9959529228, -0.97601513510,  0.23483807320, -0.99836128480,  0.5856025746, -0.94005382660, -0.76398756690,  0.6244544645,
		 0.04604054566,  0.588842482800,  0.77084909780, -0.811418288200,  0.97867662120, -0.9984329822,  0.09125496582, -0.4492438803, -0.3636982357,  0.94434055750, -0.94762546450, -0.68186765350, -0.6113610831,  0.97540709480, -0.09381081730, -0.7029540015,
		-0.60856911090, -0.087188628810, -0.23738192600,  0.291342313200,  0.96148724260,  0.8836361266, -0.27499741960, -0.8108932717, -0.8913607575,  0.12925554100, -0.33426371040, -0.19212493370, -0.7566302845, -0.95631643390, -0.97443581460,  0.9836522982,
		-0.28636157320,  0.833701687200,  0.36837019370,  0.765711910200, -0.02312427772,  0.8875600535,  0.97664219100,  0.9374176384,  0.9515313457, -0.77863619370, -0.45383021250, -0.76856048740, -0.8940796454, -0.85124621540,  0.54466961330,  0.9207601495,
		-0.98930911970, -0.999868022900,  0.56173092990, -0.827741198500,  0.54563646700,  0.1690223212, -0.50792954330,  0.7685069899, -0.9630140787,  0.90152191320,  0.08905695279, -0.34235505590, -0.4661614943, -0.64496593710,  0.71393885090,  0.7472809229,
	};

	const double CELL_3D_X[] =
	{
		 0.37524986860,  0.687188096000,  0.22481352120,  0.66920066470, -0.43764769310,  0.61399725520,  0.94945639290,  0.80651088820, -0.22188128530,  0.848466116700,  0.55518175960,  0.21339034990,  0.5195126593, -0.64401419750, -0.51928973310, -0.36976540770,
		-0.07927779647,  0.418775732100, -0.75007873100,  0.65795546320, -0.68598038380, -0.68784070870,  0.94908483470,  0.57958294330, -0.53259765290, -0.136369946600,  0.41766587900, -0.91082364680,  0.4438605427,  0.81929488700, -0.40338739150, -0.28173177050,
		 0.39696656220,  0.532345013400, -0.68330172970,  0.38814366610, -0.71191447670, -0.23069798380, -0.93988730220,  0.17019066760, -0.42618394960, -0.003712295499, -0.73467500400, -0.31950460150,  0.7345307424,  0.97662464960, -0.02003735175, -0.48241563420,
		 0.42458920070,  0.907242766900,  0.59334680800, -0.89117625410, -0.76575718340, -0.52681988960, -0.88019032790, -0.62964096170, -0.09492481344, -0.492047052500,  0.73076661540, -0.25145406360, -0.3356210347, -0.35227878940,  0.87847885000, -0.74240963460,
		 0.57575852740,  0.451929933800,  0.64203686280, -0.11284784470,  0.49987488300,  0.52916817390, -0.50988371950,  0.56395835020, -0.84563865260, -0.965713487500, -0.57643734200, -0.56660130140,  0.5667702405, -0.48131658200,  0.73133899160, -0.38056285660,
		-0.65126759090, -0.278715695100,  0.86480591140, -0.97302162760, -0.83358209060,  0.26731596410,  0.23115014800,  0.01286214638,  0.67749532610,  0.654288571800, -0.02545450161,  0.21012385860, -0.5572105885,  0.81370567200, -0.75460269510, -0.25025000060,
		-0.99792893810,  0.702403703900,  0.08990874624,  0.81708124320,  0.42269802650, -0.24421534750, -0.91833267310,  0.60682224110,  0.81867669100, -0.723673528200, -0.53839032950, -0.62693372420, -0.0939331121,  0.92038785390, -0.72563968240,  0.62924311490,
		 0.42341569780,  0.006685688024, -0.25986941130,  0.64080364210,  0.05899871622,  0.70902814180, -0.59052220720,  0.31282142640, -0.69192582600,  0.363401934900, -0.67725111470, -0.32045838960, -0.3906740409, -0.33421903950, -0.51777959200, -0.68177112670,
		 0.64223831050,  0.438848247800,  0.29685626110, -0.20197783530,  0.60148650480,  0.95192807220,  0.33988895690,  0.81797093540,  0.23655221540,  0.326217509600, -0.80607159540, -0.20686425030,  0.6208057279, -0.52742825020, -0.37223349280, -0.89234129710,
		 0.53418342010, -0.366370151300, -0.61146003190,  0.50263075560,  0.83961517290,  0.92450424670, -0.79948439570, -0.53572005890, -0.62833597390, -0.613518860000, -0.87563200800, -0.52788794230,  0.9087491985, -0.03500215466, -0.26136579800, -0.57952354100,
		-0.37650526890, -0.743982520000,  0.42573180520, -0.12145089210,  0.85618097530,  0.68028351040, -0.54521310390, -0.19971564780,  0.45623483570, -0.811704301000,  0.67793962000, -0.92378191060,  0.6973511259, -0.51895060000,  0.55173200320, -0.39671083100,
		 0.54937628150, -0.250785300200,  0.47886340050,  0.38733351600, -0.21765156940,  0.67498324190,  0.21482830220, -0.75218158720,  0.46970001590,  0.789059369900, -0.76061629520,  0.01083397843,  0.5254091908, -0.67480258770,  0.75109152400,  0.05259056135,
		 0.01889481232, -0.603742372700, -0.65429651290,  0.08873301081, -0.61913456710,  0.43318584880, -0.38583519460, -0.14290597470,  0.41182210360, -0.624715321400, -0.61142301400,  0.55429396060, -0.9432768808, -0.45678704510, -0.73491335470,  0.39930448900,
		-0.74749276720,  0.025894197530,  0.78391582100,  0.61386687520,  0.42763760470, -0.43478863530,  0.02947841302, -0.83374274600,  0.38172217420, -0.874336835900, -0.38234437960, -0.68292438110, -0.3681903049, -0.36762683300, -0.43458337300,  0.23589199500,
		-0.68748802690, -0.511566177300, -0.55349626010,  0.56327770560,  0.68619153200, -0.05095871588, -0.06865785057, -0.59752885310, -0.64297900560, -0.372936154800,  0.22379176660,  0.60467732250, -0.5041542295, -0.03972191174,  0.70288284060, -0.55608564980,
		 0.58983284560, -0.930807676600,  0.46170698640,  0.31909831370,  0.91165677530, -0.45029554000,  0.33463344590,  0.85250056450,  0.25284833810, -0.830663014700, -0.68803906220,  0.74486840260, -0.1963355843, -0.59002579740,  0.90970572940, -0.25091968080,
	};

	const double CELL_3D_Y[] =
	{
		-0.6760585049, -0.09136176499,  0.16813256790, -0.6688468686000, -0.4822753902, -0.7891068824, -0.18775099440,  0.5484709140, -0.46333944300, -0.40505420820,  0.3218158513,  0.2546493823, -0.3753271935,  0.47453848870,  0.48125465200, -0.89344164890,
		-0.6737085076,  0.74699172280,  0.38262304110,  0.6751013678000, -0.7248119515, -0.3224276742, -0.02076190936, -0.6404268166, -0.52920284440,  0.71514146360, -0.6144655059, -0.3699121240,  0.6942067212, -0.44815582480, -0.63668945590,  0.59565684710,
		 0.5642745390,  0.71455846880,  0.68719183160,  0.5657918509000, -0.6275978114,  0.4146983062,  0.26389937890, -0.7926331380,  0.57061335140,  0.86065464620,  0.6490900316, -0.8242699196,  0.6765819124,  0.19595340690, -0.84267697570, -0.59176727970,
		 0.7517364266,  0.03252559226,  0.08836171050,  0.4475064813000, -0.1418643552,  0.7343428473,  0.38701925480, -0.7716703522,  0.48398983270,  0.74374390550, -0.5989573348, -0.8357068955,  0.6086049038,  0.91946272580,  0.47182972380, -0.26503358840,
		-0.6470352599, -0.55551813030,  0.12223512350,  0.7802044684000, -0.8636947022, -0.2341352163,  0.68303087400, -0.5005858287,  0.23346162110,  0.25768776080,  0.6666816727, -0.7663996863,  0.7942019820,  0.61893087880,  0.60710332610, -0.42060582530,
		-0.3957336915, -0.81702574840, -0.10432404170,  0.0002167596213,  0.1816339018, -0.6838094939, -0.24953419690, -0.7116756954, -0.03361673621, -0.33508364310,  0.2137186039,  0.2557996786,  0.7490117093,  0.49429365490, -0.35268685300, -0.39524454350,
		-0.0459964767, -0.71157874710,  0.08022899756,  0.5362268157000, -0.8258613686,  0.1114171723,  0.38828230510, -0.7915404457,  0.32509576620,  0.64013464640, -0.2662724517, -0.6727907114, -0.9947308180, -0.35963589770,  0.23446100690, -0.66452155460,
		-0.7107590611, -0.46466173270,  0.67171913550,  0.5101893498000,  0.1185768238,  0.2360050930, -0.78110240610,  0.5089325193,  0.60731876580, -0.79307325570, -0.6822767155,  0.3201532885,  0.7545302807,  0.10726644480,  0.67840331730, -0.65959249670,
		 0.7276509498,  0.55866894360, -0.64986367880,  0.6789333174000,  0.7105966551, -0.2872214155,  0.49674621700, -0.3880337977,  0.73240706040, -0.93266347490, -0.5867839255,  0.8003043651, -0.1631882481, -0.67963746810, -0.80666785030,  0.42381774180,
		 0.7715863549,  0.54553673470, -0.03205115397, -0.6005545066000, -0.5423640002,  0.3569205906, -0.58207175200,  0.6407354361,  0.77771429840, -0.09956428618,  0.1100002681,  0.8136349123,  0.2923431904,  0.97357944250,  0.83249748640, -0.61796177170,
		-0.9248386523, -0.64487807710, -0.52744027610, -0.7862170565000,  0.2682099744, -0.5848777694, -0.63645614670, -0.7167402514, -0.86770124940,  0.42052867070, -0.7007832749,  0.2432724510, -0.1899846085, -0.61461249770, -0.80933576920, -0.03545096987,
		-0.7191590868,  0.74786458480,  0.36235173280,  0.8436992512000, -0.2445711729,  0.6897356637, -0.17080707870,  0.4639272368, -0.79171866560,  0.02980025428,  0.6334156172, -0.9815544807, -0.2307217304,  0.10808233180,  0.51676017980, -0.84512001600,
		 0.4415725620,  0.58767891720, -0.63659087370,  0.6835016600000,  0.5849723959,  0.1164114357, -0.73798138840, -0.9613237178, -0.90719430840, -0.76821111050,  0.6390744590, -0.6193582980,  0.2807257131, -0.01800868791,  0.37766072890,  0.72075678230,
		 0.5536661486, -0.99740531170, -0.02047200006, -0.6739453804000, -0.5607471297,  0.8815553192,  0.82759774150,  0.3928902456,  0.55099139600,  0.42476236760, -0.3436948871, -0.3653537677,  0.3181702902, -0.60671731710, -0.89841284770,  0.42208397660,
		 0.7238407199, -0.77669136950,  0.64600378420,  0.2544775664000,  0.6488840578,  0.8050168330, -0.91838070360,  0.4144046357,  0.27058720800, -0.88136844940,  0.6985971877, -0.7795603017, -0.8624480731,  0.55326970170,  0.71117952100, -0.77981605740,
		 0.5225859041,  0.12618593680,  0.33980335820, -0.7472173667000, -0.4032647119, -0.4246578154,  0.84812123770, -0.2144838537,  0.34317144910,  0.53101882310,  0.6682978632,  0.3110433206,  0.9263293599, -0.61556005690,  0.07169784399,  0.89858887730,
	};

	const double CELL_3D_Z[] =
	{
		-0.63413912830, -0.72071183460,  0.9597866014,  0.32375042350, -0.75886424660, -0.01782410481,  0.25155938090,  0.22072572050, -0.85795411060,  0.34064106810,  0.76694704620, -0.9431957648,  0.76761715370, -0.6000491115, -0.70620969480,  0.2550207115,
		 0.73473252130,  0.51636252020, -0.5394270162,  0.33366562850, -0.06386351110, -0.65031957870,  0.31433567980, -0.50392172450,  0.66051804640, -0.68554790110, -0.66931857560,  0.1832083647, -0.56662584370,  0.3576482138, -0.65719490950, -0.7522101635,
		-0.72388658860,  0.45388873230,  0.2467106257,  0.72747788690,  0.31511706550, -0.88022937640, -0.21672327290,  0.58546378650,  0.70197410520,  0.50917560710,  0.19731895330,  0.4674354600,  0.05197599597,  0.0883547180,  0.53804648430, -0.6458224544,
		-0.50459523930,  0.41934788400,  0.8000823542, -0.07445020656, -0.62728816410, -0.42802031100, -0.27473820830, -0.08987283726,  0.86990983540,  0.45247618850, -0.32746032570,  0.4882262167, -0.71899832560,  0.1746079907,  0.07517726980, -0.6152927202,
		 0.49984746730, -0.69796772270,  0.7568667263, -0.61526120580,  0.06447140991, -0.81557448720, -0.52296024490,  0.65678368380, -0.47999056310,  0.03153534591,  0.47249924660, -0.3026458097, -0.21912258270, -0.6206922870,  0.31075525880,  0.8235670294,
		 0.64749159880, -0.50476379410,  0.4911488878, -0.23071381670, -0.52168000150,  0.67893059390,  0.94037348630,  0.70239039700,  0.73475846250,  0.67795679580,  0.97656358050, -0.9436177661, -0.35846592500, -0.3058706624,  0.55334144640, -0.8838306897,
		 0.04496841812,  0.01687374963, -0.9927133148, -0.21175231800,  0.37320152490,  0.96329905930, -0.07682417004, -0.07232213047,  0.47337217750,  0.25792297130,  0.79952162860,  0.3928189967,  0.04107517667,  0.1534542912,  0.64689650450,  0.4030684878,
		-0.56173009880, -0.88546302900,  0.6937299850, -0.57365278660, -0.99119054090, -0.66451538000,  0.20288556850,  0.80195414210, -0.39038771490, -0.48884951140, -0.27537140570, -0.8915202143,  0.52731190890,  0.9363714773, -0.52122282490, -0.3164267200,
		 0.24094407610, -0.70377640400, -0.6996810411, -0.70587145050, -0.36505667830,  0.10647442780,  0.79857291020,  0.42468025700, -0.63845355920,  0.15401616460, -0.07702731943, -0.5627789132, -0.76679191690, -0.5098159990,  0.45905250920,  0.1552595611,
		 0.34540204200,  0.75376560240,  0.7906259247, -0.62184934520,  0.02979350071, -0.13378934890, -0.14838186060,  0.54996556200,  0.01882482408, -0.78337830020,  0.47028558090,  0.2435827372,  0.29784283320,  0.2256499906,  0.48850368970,  0.5312962584,
		 0.05401156992,  0.17499221580, -0.7352273018,  0.60589802840,  0.44160791110,  0.44173786380,  0.54558798070, -0.66812953240,  0.19734314410,  0.40532920550,  0.22203754920,  0.2957118467,  0.69109135120,  0.5940890106, -0.20141352830, -0.9172588213,
		-0.42543614010, -0.61465868250, -0.7996193253, -0.37167771110, -0.94488768420, -0.26203499240,  0.96159957490, -0.46796835240,  0.39059371440,  0.61359372200,  0.14229373580,  0.1908754211,  0.81897049120, -0.7300408736, -0.41087764510, -0.5319834504,
		-0.89702656510, -0.53863590450,  0.4082255906,  0.72453566760,  0.52390808730, -0.89375522260, -0.55363767300,  0.23544551820, -0.08602930750, -0.13993733180, -0.46663233270,  0.5560157407,  0.17726195330, -0.8893937725, -0.56327145760, -0.5666264959,
		-0.36702637360, -0.06717242579,  0.6205295181, -0.41105362640,  0.70900545530,  0.18389959700, -0.56054705550,  0.38795655480,  0.74208939030, -0.23475951180, -0.85772174970,  0.6325590203, -0.87361522760,  0.7048011129, -0.06317948268,  0.8753285574,
		-0.05843650473, -0.36749226220, -0.5256624401,  0.78610393370,  0.32877144160,  0.59105930990, -0.38969601340,  0.68646053610,  0.71649184310, -0.29001427700, -0.67961696170,  0.1632515592,  0.04485347486,  0.8320545697,  0.01339408056, -0.2874989857,
		 0.61563072300,  0.34303670140,  0.8193658136, -0.58296009570,  0.07911697781,  0.78542960630, -0.41074423060,  0.47669640660, -0.90459995270, -0.16738567870,  0.28280773480, -0.5902737632, -0.32150622900, -0.5224513133, -0.40901699850, -0.3599685311,
	};
#pragma endregion

#pragma region Constructor & destructor
	CNoise::CNoise(const int seed):
		m_iSeed{ seed - 1 },
		m_iOctaves{ 3 },
		m_fFrequency{ 0.01 },
		m_fLacunarity{ 2.0 },
		m_fGain{ 0.5 },
		m_eNoiseType{ NoiseType::SimplexFractal },
		m_eInterpolationType{ InterpolationType::Quintic },
		m_eFractalType{ FractalType::FBM },
		m_eCellularDistance{ CellularDistance::Euclidean },
		m_eCellularReturn{ CellularReturn::CellValue },
		m_iCellularDistanceIndex0{ 0 },
		m_iCellularDistanceIndex1{ 1 },
		m_fCellularJitter{ 0.45 },
		m_fGradientPerturbAmplitude{ 1.0 },
		m_pCellularNoiseLookup{ nullptr }
	{
		setSeed(seed);
		CalculateFractalBounding();
	}
#pragma endregion

#pragma region Getters
	int CNoise::getSeed() const
	{
		return m_iSeed;
	}

	int CNoise::getOctaves() const
	{
		return m_iOctaves;
	}

	double CNoise::getFrequency() const
	{
		return m_fFrequency;
	}

	double CNoise::getLacunarity() const
	{
		return m_fLacunarity;
	}

	double CNoise::getGain() const
	{
		return m_fGain;
	}

	CNoise::NoiseType CNoise::getNoiseType() const
	{
		return m_eNoiseType;
	}

	CNoise::InterpolationType CNoise::getInterpolationType() const
	{
		return m_eInterpolationType;
	}

	CNoise::FractalType CNoise::getFractalType() const
	{
		return m_eFractalType;
	}

	CNoise::CellularDistance CNoise::getCellularDistance() const
	{
		return m_eCellularDistance;
	}

	CNoise::CellularReturn CNoise::getCellularReturn() const
	{
		return m_eCellularReturn;
	}

	int CNoise::getCellularDistanceIndex0() const
	{
		return m_iCellularDistanceIndex0;
	}

	int CNoise::getCellularDistanceIndex1() const
	{
		return m_iCellularDistanceIndex1;
	}

	double CNoise::getCellularJitter() const
	{
		return m_fCellularJitter;
	}

	double CNoise::getGradientPerturbAmplitude() const
	{
		return m_fGradientPerturbAmplitude;
	}

	CNoise *CNoise::getCellularNoiseLookup()
	{
		return m_pCellularNoiseLookup;
	}
#pragma endregion

#pragma region Setters
	bool CNoise::setSeed(const int value)
	{
		if (value != m_iSeed)
		{
			m_iSeed = value;
			std::mt19937_64 gen{ (unsigned long long)m_iSeed };
			for (int i = 0; i < 256; i++)
				m_aPerm[i] = (unsigned char)i;
			for (int j = 0; j < 256; j++)
			{
				int rng{ int(gen() % (256 - j)) };
				int k{ rng + j };
				int l{ m_aPerm[j] };
				m_aPerm[j] = m_aPerm[j + 256] = m_aPerm[k];
				m_aPerm[k] = (unsigned char)l;
				m_aPerm12[j] = m_aPerm12[j + 256] = m_aPerm[j] % 12;
			}
			return true;
		}
		return false;
	}

	bool CNoise::setOctaves(const int value)
	{
		if (value > 0 && value != m_iOctaves)
		{
			m_iOctaves = value;
			CalculateFractalBounding();
			return true;
		}
		return false;
	}

	bool CNoise::setFrequency(const double value)
	{
		if (value != 0 && value != m_fFrequency)
		{
			m_fFrequency = value;
			return true;
		}
		return false;
	}

	bool CNoise::setLacunarity(const double value)
	{
		if (value != m_fLacunarity)
		{
			m_fLacunarity = value;
			return true;
		}
		return false;
	}

	bool CNoise::setGain(const double value)
	{
		if (value != m_fGain)
		{
			m_fGain = value;
			CalculateFractalBounding();
			return true;
		}
		return false;
	}

	bool CNoise::setNoiseType(const NoiseType value)
	{
		if (value != m_eNoiseType)
		{
			m_eNoiseType = value;
			return true;
		}
		return false;
	}

	bool CNoise::setInterpolationType(const InterpolationType value)
	{
		if (value != m_eInterpolationType)
		{
			m_eInterpolationType = value;
			return true;
		}
		return false;
	}

	bool CNoise::setFractalType(const FractalType value)
	{
		if (value != m_eFractalType)
		{
			m_eFractalType = value;
			return true;
		}
		return false;
	}

	bool CNoise::setCellularDistance(const CellularDistance value)
	{
		if (value != m_eCellularDistance)
		{
			m_eCellularDistance = value;
			return true;
		}
		return false;
	}

	bool CNoise::setCellularReturn(const CellularReturn value)
	{
		if (value != m_eCellularReturn)
		{
			m_eCellularReturn = value;
			return true;
		}
		return false;
	}

	bool CNoise::setCellularDistanceIndex0(const int value)
	{
		if (value >= 0 && value < 4 && value != m_iCellularDistanceIndex0)
		{
			m_iCellularDistanceIndex0 = value;
			if (m_iCellularDistanceIndex1 < m_iCellularDistanceIndex0)
				m_iCellularDistanceIndex1 = m_iCellularDistanceIndex0;
			return true;
		}
		return false;
	}

	bool CNoise::setCellularDistanceIndex1(const int value)
	{
		if (value >= 0 && value < 4 && value != m_iCellularDistanceIndex1)
		{
			m_iCellularDistanceIndex1 = value;
			if (m_iCellularDistanceIndex0 > m_iCellularDistanceIndex1)
				m_iCellularDistanceIndex0 = m_iCellularDistanceIndex1;
			return true;
		}
		return false;
	}

	bool CNoise::setCellularJitter(const double value)
	{
		if (value != m_fCellularJitter)
		{
			m_fCellularJitter = value;
			return true;
		}
		return false;
	}

	bool CNoise::setGradientPerturbAmplitude(const double value)
	{
		if (value != m_fGradientPerturbAmplitude)
		{
			m_fGradientPerturbAmplitude = value;
			return true;
		}
		return false;
	}

	bool CNoise::setCellularNoiseLookup(CNoise *value)
	{
		if (value != m_pCellularNoiseLookup)
		{
			m_pCellularNoiseLookup = value;
			return true;
		}
		return false;
	}
#pragma endregion

#pragma region Helpers
	void CNoise::CalculateFractalBounding()
	{
		double amp{ m_fGain }, ampFractal{ 1 };
		for (int i = 1; i < m_iOctaves; i++)
		{
			ampFractal += amp;
			amp *= m_fGain;
		}
		m_fFractalBounding = 1 / ampFractal;
	}

	int CNoise::FastFloor(const double f) const
	{
		return f >= 0 ? (int)f : (int)f - 1;
	}

	int CNoise::FastRound(const double f) const
	{
		return (f >= 0) ? (int)(f + 0.5) : (int)(f - 0.5);
	}

	int CNoise::FastAbs(const int i) const
	{
		return std::abs(i);
	}

	double CNoise::FastAbs(const double f) const
	{
		return std::fabs(f);
	}

	double CNoise::Lerp(const double a, const double b, const double t) const
	{
		return a + t * (b - a);
	}

	double CNoise::InterpHermiteFunc(const double t) const
	{
		return t * t * (3 - 2 * t);
	}

	double CNoise::InterpQuinticFunc(const double t) const
	{
		return t * t * t * (t * (t * 6 - 15) + 10);
	}

	double CNoise::CubicLerp(const double a, const double b, const double c, const double d, const double t) const
	{
		double p{ (d - c) - (a - b) };
		return t * t * t * p + t * t * ((a - b) - p) + t * (c - a) + b;
	}

	double CNoise::ValCoord2D(const int seed, const int x, const int y) const
	{
		int n{ seed };
		n ^= X_PRIME * x;
		n ^= Y_PRIME * y;
		return (n * n * n * 60493) / double(2147483648);
	}

	double CNoise::ValCoord3D(const int seed, const int x, const int y, const int z) const
	{
		int n{ seed };
		n ^= X_PRIME * x;
		n ^= Y_PRIME * y;
		n ^= Z_PRIME * z;
		return (n * n * n * 60493) / double(2147483648);
	}

	double CNoise::ValCoord4D(const int seed, const int x, const int y, const int z, const int w) const
	{
		int n{ seed };
		n ^= X_PRIME * x;
		n ^= Y_PRIME * y;
		n ^= Z_PRIME * z;
		n ^= W_PRIME * w;
		return (n * n * n * 60493) / double(2147483648);
	}

	unsigned char CNoise::Index2D_12(const unsigned char offset, const int x, const int y) const
	{
		return m_aPerm12[(x & 0xff) + m_aPerm[(y & 0xff) + offset]];
	}

	unsigned char CNoise::Index3D_12(const unsigned char offset, const int x, const int y, const int z) const
	{
		return m_aPerm12[(x & 0xff) + m_aPerm[(y & 0xff) + m_aPerm[(z & 0xff) + offset]]];
	}

	unsigned char CNoise::Index4D_32(const unsigned char offset, const int x, const int y, const int z, const int w) const
	{
		return m_aPerm[(x & 0xff) + m_aPerm[(y & 0xff) + m_aPerm[(z & 0xff) + m_aPerm[(w & 0xff) + offset]]]] & 31;
	}

	unsigned char CNoise::Index2D_256(const unsigned char offset, const int x, const int y) const
	{
		return m_aPerm[(x & 0xff) + m_aPerm[(y & 0xff) + offset]];
	}

	unsigned char CNoise::Index3D_256(const unsigned char offset, const int x, const int y, const int z) const
	{
		return m_aPerm[(x & 0xff) + m_aPerm[(y & 0xff) + m_aPerm[(z & 0xff) + offset]]];
	}

	unsigned char CNoise::Index4D_256(const unsigned char offset, const int x, const int y, const int z, const int w) const
	{
		return m_aPerm[(x & 0xff) + m_aPerm[(y & 0xff) + m_aPerm[(z & 0xff) + m_aPerm[(w & 0xff) + offset]]]];
	}

	double CNoise::ValCoord2DFast(const unsigned char offset, const int x, const int y) const
	{
		return VAL_LUT[Index2D_256(offset, x, y)];
	}

	double CNoise::ValCoord3DFast(const unsigned char offset, const int x, const int y, const int z) const
	{
		return VAL_LUT[Index3D_256(offset, x, y, z)];
	}

	double CNoise::GradCoord2D(const unsigned char offset, const int x, const int y, const double xd, const double yd) const
	{
		unsigned char lutPos{ Index2D_12(offset, x, y) };
		return xd * GRAD_X[lutPos] + yd * GRAD_Y[lutPos];
	}

	double CNoise::GradCoord3D(const unsigned char offset, const int x, const int y, const int z, const double xd, const double yd, const double zd) const
	{
		unsigned char lutPos{ Index3D_12(offset, x, y, z) };
		return xd * GRAD_X[lutPos] + yd * GRAD_Y[lutPos] + zd * GRAD_Z[lutPos];
	}

	double CNoise::GradCoord4D(const unsigned char offset, const int x, const int y, const int z, const int w, const double xd, const double yd, const double zd, const double wd) const
	{
		unsigned char lutPos{ (unsigned char)(Index4D_32(offset, x, y, z, w) << 2) };
		return xd * GRAD_4D[lutPos] + yd * GRAD_4D[lutPos + 1] + zd * GRAD_4D[lutPos + 2] + wd * GRAD_4D[lutPos + 3];
	}
#pragma endregion

#pragma region 2D noise helpers
	double CNoise::SingleValueFractalFBM(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ SingleValue(m_aPerm[0], x, y) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum += SingleValue(m_aPerm[i], x, y) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SingleValueFractalBillow(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ FastAbs(SingleValue(m_aPerm[0], x, y)) * 2 - 1 };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum += (FastAbs(SingleValue(m_aPerm[i], x, y)) * 2 - 1) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SingleValueFractalRigidMulti(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ 1 - FastAbs(SingleValue(m_aPerm[0], x, y)) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum -= (1 - FastAbs(SingleValue(m_aPerm[i], x, y))) * amp;
		}
		return sum;
	}

	double CNoise::SingleValue(const unsigned char offset, const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		int x0{ FastFloor(x) };
		int y0{ FastFloor(y) };
		int x1{ x0 + 1 };
		int y1{ y0 + 1 };
		double xs{ 0 }, ys{ 0 };
		switch (m_eInterpolationType)
		{
		case InterpolationType::Linear:
			xs = x - x0;
			ys = y - y0;
			break;
		case InterpolationType::Hermite:
			xs = InterpHermiteFunc(x - x0);
			ys = InterpHermiteFunc(y - y0);
			break;
		case InterpolationType::Quintic:
			xs = InterpQuinticFunc(x - x0);
			ys = InterpQuinticFunc(y - y0);
			break;
		}
		double xf0{ Lerp(ValCoord2DFast(offset, x0, y0), ValCoord2DFast(offset, x1, y0), xs) };
		double xf1{ Lerp(ValCoord2DFast(offset, x0, y1), ValCoord2DFast(offset, x1, y1), xs) };
		return Lerp(xf0, xf1, ys);
	}

	double CNoise::SinglePerlinFractalFBM(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ SinglePerlin(m_aPerm[0], x, y) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum += SinglePerlin(m_aPerm[i], x, y) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SinglePerlinFractalBillow(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ FastAbs(SinglePerlin(m_aPerm[0], x, y)) * 2 - 1 };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum += (FastAbs(SinglePerlin(m_aPerm[i], x, y)) * 2 - 1) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SinglePerlinFractalRigidMulti(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ 1 - FastAbs(SinglePerlin(m_aPerm[0], x, y)) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum -= (1 - FastAbs(SinglePerlin(m_aPerm[i], x, y))) * amp;
		}
		return sum;
	}

	double CNoise::SinglePerlin(unsigned char offset, const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		int x0{ FastFloor(x) };
		int y0{ FastFloor(y) };
		int x1{ x0 + 1 };
		int y1{ y0 + 1 };
		double xs{ 0 }, ys{ 0 };
		switch (m_eInterpolationType)
		{
		case InterpolationType::Linear:
			xs = x - x0;
			ys = y - y0;
			break;
		case InterpolationType::Hermite:
			xs = InterpHermiteFunc(x - x0);
			ys = InterpHermiteFunc(y - y0);
			break;
		case InterpolationType::Quintic:
			xs = InterpQuinticFunc(x - x0);
			ys = InterpQuinticFunc(y - y0);
			break;
		}
		double xd0{ x - x0 };
		double yd0{ y - y0 };
		double xd1{ xd0 - 1 };
		double yd1{ yd0 - 1 };
		double xf0{ Lerp(GradCoord2D(offset, x0, y0, xd0, yd0), GradCoord2D(offset, x1, y0, xd1, yd0), xs) };
		double xf1{ Lerp(GradCoord2D(offset, x0, y1, xd0, yd1), GradCoord2D(offset, x1, y1, xd1, yd1), xs) };
		return Lerp(xf0, xf1, ys);
	}

	double CNoise::SingleSimplexFractalFBM(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ SingleSimplex(m_aPerm[0], x, y) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum += SingleSimplex(m_aPerm[i], x, y) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SingleSimplexFractalBillow(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ FastAbs(SingleSimplex(m_aPerm[0], x, y)) * 2 - 1 };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum += (FastAbs(SingleSimplex(m_aPerm[i], x, y)) * 2 - 1) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SingleSimplexFractalRigidMulti(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ 1 - FastAbs(SingleSimplex(m_aPerm[0], x, y)) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum -= (1 - FastAbs(SingleSimplex(m_aPerm[i], x, y))) * amp;
		}
		return sum;
	}

	double CNoise::SingleSimplexFractalBlend(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ SingleSimplex(m_aPerm[0], x, y) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum *= SingleSimplex(m_aPerm[i], x, y) * amp + 1;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SingleSimplex(const unsigned char offset, const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double t{ (x + y) * F2 };
		int i{ FastFloor(x + t) };
		int j{ FastFloor(y + t) };
		t = (i + j) * G2;
		double X0{ i - t };
		double Y0{ j - t };
		double x0{ x - X0 };
		double y0{ y - Y0 };
		int i1, j1;
		if (x0 > y0)
		{
			i1 = 1;
			j1 = 0;
		}
		else
		{
			i1 = 0;
			j1 = 1;
		}
		double x1{ x0 - i1 + G2 };
		double y1{ y0 - j1 + G2 };
		double x2{ x0 - 1 + 2 * G2 };
		double y2{ y0 - 1 + 2 * G2 };
		double n0, n1, n2;
		t = 0.5 - x0 * x0 - y0 * y0;
		if (t < 0)
			n0 = 0;
		else
		{
			t *= t;
			n0 = t * t * GradCoord2D(offset, i, j, x0, y0);
		}
		t = 0.5 - x1 * x1 - y1 * y1;
		if (t < 0)
			n1 = 0;
		else
		{
			t *= t;
			n1 = t * t * GradCoord2D(offset, i + i1, j + j1, x1, y1);
		}
		t = 0.5 - x2 * x2 - y2 * y2;
		if (t < 0)
			n2 = 0;
		else
		{
			t *= t;
			n2 = t * t * GradCoord2D(offset, i + 1, j + 1, x2, y2);
		}
		return 70 * (n0 + n1 + n2);
	}

	double CNoise::SingleCubicFractalFBM(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ SingleCubic(m_aPerm[0], x, y) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum += SingleCubic(m_aPerm[i], x, y) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SingleCubicFractalBillow(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ FastAbs(SingleCubic(m_aPerm[0], x, y)) * 2 - 1 };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum += (FastAbs(SingleCubic(m_aPerm[i], x, y)) * 2 - 1) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double CNoise::SingleCubicFractalRigidMulti(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		double sum{ 1 - FastAbs(SingleCubic(m_aPerm[0], x, y)) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			amp *= m_fGain;
			sum -= (1 - FastAbs(SingleCubic(m_aPerm[i], x, y))) * amp;
		}
		return sum;
	}

	double CNoise::SingleCubic(const unsigned char offset, const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		int x1{ FastFloor(x) };
		int y1{ FastFloor(y) };
		int x0{ x1 - 1 };
		int y0{ y1 - 1 };
		int x2{ x1 + 1 };
		int y2{ y1 + 1 };
		int x3{ x1 + 2 };
		int y3{ y1 + 2 };
		double xs{ x - x1 };
		double ys{ y - y1 };
		return CubicLerp(
			CubicLerp(ValCoord2DFast(offset, x0, y0), ValCoord2DFast(offset, x1, y0), ValCoord2DFast(offset, x2, y0), ValCoord2DFast(offset, x3, y0), xs),
			CubicLerp(ValCoord2DFast(offset, x0, y1), ValCoord2DFast(offset, x1, y1), ValCoord2DFast(offset, x2, y1), ValCoord2DFast(offset, x3, y1), xs),
			CubicLerp(ValCoord2DFast(offset, x0, y2), ValCoord2DFast(offset, x1, y2), ValCoord2DFast(offset, x2, y2), ValCoord2DFast(offset, x3, y2), xs),
			CubicLerp(ValCoord2DFast(offset, x0, y3), ValCoord2DFast(offset, x1, y3), ValCoord2DFast(offset, x2, y3), ValCoord2DFast(offset, x3, y3), xs),
			ys) * CUBIC_2D_BOUNDING;
	}

	double CNoise::SingleCellular(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		int xr{ FastRound(x) };
		int yr{ FastRound(y) };
		double distance{ 999999 };
		int xc{ 0 }, yc{ 0 };
		switch (m_eCellularDistance)
		{
		default:
		case CellularDistance::Euclidean:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					unsigned char lutPos{ Index2D_256(0, xi, yi) };
					double vecX{ xi - x + CELL_2D_X[lutPos] * m_fCellularJitter };
					double vecY{ yi - y + CELL_2D_Y[lutPos] * m_fCellularJitter };
					double newDistance{ vecX * vecX + vecY * vecY };
					if (newDistance < distance)
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
					}
				}
			}
			break;
		case CellularDistance::Manhattan:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					unsigned char lutPos{ Index2D_256(0, xi, yi) };
					double vecX{ xi - x + CELL_2D_X[lutPos] * m_fCellularJitter };
					double vecY{ yi - y + CELL_2D_Y[lutPos] * m_fCellularJitter };
					double newDistance{ FastAbs(vecX) + FastAbs(vecY) };
					if (newDistance < distance)
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
					}
				}
			}
			break;
		case CellularDistance::Natural:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					unsigned char lutPos = Index2D_256(0, xi, yi);
					double vecX{ xi - x + CELL_2D_X[lutPos] * m_fCellularJitter };
					double vecY{ yi - y + CELL_2D_Y[lutPos] * m_fCellularJitter };
					double newDistance{ (FastAbs(vecX) + FastAbs(vecY)) + (vecX * vecX + vecY * vecY) };
					if (newDistance < distance)
					{
						distance = newDistance;
						xc = xi;
						yc = yi;
					}
				}
			}
			break;
		}

		switch (m_eCellularReturn)
		{
		case CellularReturn::CellValue:
			return ValCoord2D(m_iSeed, xc, yc);
		case CellularReturn::NoiseLookup:
			if (m_pCellularNoiseLookup)
			{
				unsigned char lutPos{ Index2D_256(0, xc, yc) };
				return m_pCellularNoiseLookup->CalculateNoise(xc + CELL_2D_X[lutPos] * m_fCellularJitter, yc + CELL_2D_Y[lutPos] * m_fCellularJitter);
			}
			break;
		case CellularReturn::Distance:
			return distance;
		default:
			break;
		}
		return 0;
	}

	double CNoise::SingleCellular2Edge(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		int xr{ FastRound(x) };
		int yr{ FastRound(y) };
		double distance[4] = { 999999,999999,999999,999999 };
		switch (m_eCellularDistance)
		{
		default:
		case CellularDistance::Euclidean:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					unsigned char lutPos{ Index2D_256(0, xi, yi) };
					double vecX{ xi - x + CELL_2D_X[lutPos] * m_fCellularJitter };
					double vecY{ yi - y + CELL_2D_Y[lutPos] * m_fCellularJitter };
					double newDistance{ vecX * vecX + vecY * vecY };
					for (int i = m_iCellularDistanceIndex1; i > 0; i--)
						distance[i] = fmax(fmin(distance[i], newDistance), distance[i - 1]);
					distance[0] = fmin(distance[0], newDistance);
				}
			}
			break;
		case CellularDistance::Manhattan:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					unsigned char lutPos{ Index2D_256(0, xi, yi) };
					double vecX{ xi - x + CELL_2D_X[lutPos] * m_fCellularJitter };
					double vecY{ yi - y + CELL_2D_Y[lutPos] * m_fCellularJitter };
					double newDistance{ FastAbs(vecX) + FastAbs(vecY) };
					for (int i = m_iCellularDistanceIndex1; i > 0; i--)
						distance[i] = fmax(fmin(distance[i], newDistance), distance[i - 1]);
					distance[0] = fmin(distance[0], newDistance);
				}
			}
			break;
		case CellularDistance::Natural:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					unsigned char lutPos{ Index2D_256(0, xi, yi) };
					double vecX{ xi - x + CELL_2D_X[lutPos] * m_fCellularJitter };
					double vecY{ yi - y + CELL_2D_Y[lutPos] * m_fCellularJitter };
					double newDistance{ (FastAbs(vecX) + FastAbs(vecY)) + (vecX * vecX + vecY * vecY) };
					for (int i = m_iCellularDistanceIndex1; i > 0; i--)
						distance[i] = fmax(fmin(distance[i], newDistance), distance[i - 1]);
					distance[0] = fmin(distance[0], newDistance);
				}
			}
			break;
		}
		switch (m_eCellularReturn)
		{
		case CellularReturn::Distance2:
			return distance[m_iCellularDistanceIndex1];
		case CellularReturn::Distance2Add:
			return distance[m_iCellularDistanceIndex1] + distance[m_iCellularDistanceIndex0];
		case CellularReturn::Distance2Sub:
			return distance[m_iCellularDistanceIndex1] - distance[m_iCellularDistanceIndex0];
		case CellularReturn::Distance2Mul:
			return distance[m_iCellularDistanceIndex1] * distance[m_iCellularDistanceIndex0];
		case CellularReturn::Distance2Div:
			return distance[m_iCellularDistanceIndex0] / distance[m_iCellularDistanceIndex1];
		default:
			return 0;
		}
	}

	void CNoise::SingleGradientPerturb(const unsigned char offset, const double warpAmp, const double frequency, double &x, double &y) const
	{
		double xf{ x * frequency };
		double yf{ y * frequency };
		int x0{ FastFloor(xf) };
		int y0{ FastFloor(yf) };
		int x1{ x0 + 1 };
		int y1{ y0 + 1 };
		double xs{ 0 }, ys{ 0 };
		switch (m_eInterpolationType)
		{
		default:
		case InterpolationType::Linear:
			xs = xf - x0;
			ys = yf - y0;
			break;
		case InterpolationType::Hermite:
			xs = InterpHermiteFunc(xf - x0);
			ys = InterpHermiteFunc(yf - y0);
			break;
		case InterpolationType::Quintic:
			xs = InterpQuinticFunc(xf - x0);
			ys = InterpQuinticFunc(yf - y0);
			break;
		}
		int lutPos0 = Index2D_256(offset, x0, y0);
		int lutPos1 = Index2D_256(offset, x1, y0);
		double lx0x{ Lerp(CELL_2D_X[lutPos0], CELL_2D_X[lutPos1], xs) };
		double ly0x{ Lerp(CELL_2D_Y[lutPos0], CELL_2D_Y[lutPos1], xs) };
		lutPos0 = Index2D_256(offset, x0, y1);
		lutPos1 = Index2D_256(offset, x1, y1);
		double lx1x{ Lerp(CELL_2D_X[lutPos0], CELL_2D_X[lutPos1], xs) };
		double ly1x{ Lerp(CELL_2D_Y[lutPos0], CELL_2D_Y[lutPos1], xs) };
		x += Lerp(lx0x, lx1x, ys) * warpAmp;
		y += Lerp(ly0x, ly1x, ys) * warpAmp;
	}
#pragma endregion

#pragma region 3D noise helpers
	double  CNoise::SingleValueFractalFBM(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ SingleValue(m_aPerm[0], x, y, z) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum += SingleValue(m_aPerm[i], x, y, z) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double  CNoise::SingleValueFractalBillow(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ FastAbs(SingleValue(m_aPerm[0], x, y, z)) * 2 - 1 };
		double amp{1};
		int i{ 0 };

		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum += (FastAbs(SingleValue(m_aPerm[i], x, y, z)) * 2 - 1) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double  CNoise::SingleValueFractalRigidMulti(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ 1 - FastAbs(SingleValue(m_aPerm[0], x, y, z)) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum -= (1 - FastAbs(SingleValue(m_aPerm[i], x, y, z))) * amp;
		}
		return sum;
	}

	double  CNoise::SingleValue(const unsigned char offset, const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		int x0{ FastFloor(x) };
		int y0{ FastFloor(y) };
		int z0{ FastFloor(z) };
		int x1{ x0 + 1 };
		int y1{ y0 + 1 };
		int z1{ z0 + 1 };
		double xs{ 0 }, ys{ 0 }, zs{ 0 };
		switch (m_eInterpolationType)
		{
		case InterpolationType::Linear:
			xs = x - x0;
			ys = y - y0;
			zs = z - z0;
			break;
		case InterpolationType::Hermite:
			xs = InterpHermiteFunc(x - x0);
			ys = InterpHermiteFunc(y - y0);
			zs = InterpHermiteFunc(z - z0);
			break;
		case InterpolationType::Quintic:
			xs = InterpQuinticFunc(x - x0);
			ys = InterpQuinticFunc(y - y0);
			zs = InterpQuinticFunc(z - z0);
			break;
		}
		double xf00{ Lerp(ValCoord3DFast(offset, x0, y0, z0), ValCoord3DFast(offset, x1, y0, z0), xs) };
		double xf10{ Lerp(ValCoord3DFast(offset, x0, y1, z0), ValCoord3DFast(offset, x1, y1, z0), xs) };
		double xf01{ Lerp(ValCoord3DFast(offset, x0, y0, z1), ValCoord3DFast(offset, x1, y0, z1), xs) };
		double xf11{ Lerp(ValCoord3DFast(offset, x0, y1, z1), ValCoord3DFast(offset, x1, y1, z1), xs) };
		double yf0{ Lerp(xf00, xf10, ys) };
		double yf1{ Lerp(xf01, xf11, ys) };
		return Lerp(yf0, yf1, zs);
	}

	double  CNoise::SinglePerlinFractalFBM(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ SinglePerlin(m_aPerm[0], x, y, z) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum += SinglePerlin(m_aPerm[i], x, y, z) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double  CNoise::SinglePerlinFractalBillow(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ FastAbs(SinglePerlin(m_aPerm[0], x, y, z)) * 2 - 1 };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum += (FastAbs(SinglePerlin(m_aPerm[i], x, y, z)) * 2 - 1) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double  CNoise::SinglePerlinFractalRigidMulti(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ 1 - FastAbs(SinglePerlin(m_aPerm[0], x, y, z)) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum -= (1 - FastAbs(SinglePerlin(m_aPerm[i], x, y, z))) * amp;
		}
		return sum;
	}

	double  CNoise::SinglePerlin(const unsigned char offset, const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		int x0{ FastFloor(x) };
		int y0{ FastFloor(y) };
		int z0{ FastFloor(z) };
		int x1{ x0 + 1 };
		int y1{ y0 + 1 };
		int z1{ z0 + 1 };
		double xs{ 0 }, ys{ 0 }, zs{ 0 };
		switch (m_eInterpolationType)
		{
		case InterpolationType::Linear:
			xs = x - x0;
			ys = y - y0;
			zs = z - z0;
			break;
		case InterpolationType::Hermite:
			xs = InterpHermiteFunc(x - x0);
			ys = InterpHermiteFunc(y - y0);
			zs = InterpHermiteFunc(z - z0);
			break;
		case InterpolationType::Quintic:
			xs = InterpQuinticFunc(x - x0);
			ys = InterpQuinticFunc(y - y0);
			zs = InterpQuinticFunc(z - z0);
			break;
		}
		double xd0{ x - x0 };
		double yd0{ y - y0 };
		double zd0{ z - z0 };
		double xd1{ xd0 - 1 };
		double yd1{ yd0 - 1 };
		double zd1{ zd0 - 1 };
		double xf00{ Lerp(GradCoord3D(offset, x0, y0, z0, xd0, yd0, zd0), GradCoord3D(offset, x1, y0, z0, xd1, yd0, zd0), xs) };
		double xf10{ Lerp(GradCoord3D(offset, x0, y1, z0, xd0, yd1, zd0), GradCoord3D(offset, x1, y1, z0, xd1, yd1, zd0), xs) };
		double xf01{ Lerp(GradCoord3D(offset, x0, y0, z1, xd0, yd0, zd1), GradCoord3D(offset, x1, y0, z1, xd1, yd0, zd1), xs) };
		double xf11{ Lerp(GradCoord3D(offset, x0, y1, z1, xd0, yd1, zd1), GradCoord3D(offset, x1, y1, z1, xd1, yd1, zd1), xs) };
		double yf0{ Lerp(xf00, xf10, ys) };
		double yf1{ Lerp(xf01, xf11, ys) };
		return Lerp(yf0, yf1, zs);
	}

	double  CNoise::SingleSimplexFractalFBM(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ SingleSimplex(m_aPerm[0], x, y, z) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum += SingleSimplex(m_aPerm[i], x, y, z) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double  CNoise::SingleSimplexFractalBillow(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ FastAbs(SingleSimplex(m_aPerm[0], x, y, z)) * 2 - 1 };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum += (FastAbs(SingleSimplex(m_aPerm[i], x, y, z)) * 2 - 1) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double  CNoise::SingleSimplexFractalRigidMulti(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ 1 - FastAbs(SingleSimplex(m_aPerm[0], x, y, z)) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum -= (1 - FastAbs(SingleSimplex(m_aPerm[i], x, y, z))) * amp;
		}
		return sum;
	}

	double  CNoise::SingleSimplex(const unsigned char offset, const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double t{ (x + y + z) * F3 };
		int i{ FastFloor(x + t) };
		int j{ FastFloor(y + t) };
		int k{ FastFloor(z + t) };
		t = (i + j + k) * G3;
		double X0{ i - t };
		double Y0{ j - t };
		double Z0{ k - t };
		double x0{ x - X0 };
		double y0{ y - Y0 };
		double z0{ z - Z0 };
		int i1, j1, k1;
		int i2, j2, k2;

		if (x0 >= y0)
		{
			if (y0 >= z0)
			{
				i1 = 1;
				j1 = 0;
				k1 = 0;
				i2 = 1;
				j2 = 1;
				k2 = 0;
			}
			else if (x0 >= z0)
			{
				i1 = 1;
				j1 = 0;
				k1 = 0;
				i2 = 1;
				j2 = 0;
				k2 = 1;
			}
			else // x0 < z0
			{
				i1 = 0;
				j1 = 0;
				k1 = 1;
				i2 = 1;
				j2 = 0;
				k2 = 1;
			}
		}
		else // x0 < y0
		{
			if (y0 < z0)
			{
				i1 = 0;
				j1 = 0;
				k1 = 1;
				i2 = 0;
				j2 = 1;
				k2 = 1;
			}
			else if (x0 < z0)
			{
				i1 = 0;
				j1 = 1;
				k1 = 0;
				i2 = 0;
				j2 = 1;
				k2 = 1;
			}
			else // x0 >= z0
			{
				i1 = 0;
				j1 = 1;
				k1 = 0;
				i2 = 1;
				j2 = 1;
				k2 = 0;
			}
		}
		double x1{ x0 - i1 + G3 };
		double y1{ y0 - j1 + G3 };
		double z1{ z0 - k1 + G3 };
		double x2{ x0 - i2 + 2 * G3 };
		double y2{ y0 - j2 + 2 * G3 };
		double z2{ z0 - k2 + 2 * G3 };
		double x3{ x0 - 1 + 3 * G3 };
		double y3{ y0 - 1 + 3 * G3 };
		double z3{ z0 - 1 + 3 * G3 };
		double n0, n1, n2, n3;
		t = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if (t < 0)
			n0 = 0;
		else
		{
			t *= t;
			n0 = t * t * GradCoord3D(offset, i, j, k, x0, y0, z0);
		}
		t = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if (t < 0)
			n1 = 0;
		else
		{
			t *= t;
			n1 = t * t * GradCoord3D(offset, i + i1, j + j1, k + k1, x1, y1, z1);
		}
		t = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if (t < 0)
			n2 = 0;
		else
		{
			t *= t;
			n2 = t * t * GradCoord3D(offset, i + i2, j + j2, k + k2, x2, y2, z2);
		}
		t = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if (t < 0)
			n3 = 0;
		else
		{
			t *= t;
			n3 = t * t * GradCoord3D(offset, i + 1, j + 1, k + 1, x3, y3, z3);
		}
		return 32 * (n0 + n1 + n2 + n3);
	}

	double  CNoise::SingleCubicFractalFBM(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ SingleCubic(m_aPerm[0], x, y, z) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum += SingleCubic(m_aPerm[i], x, y, z) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double  CNoise::SingleCubicFractalBillow(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ FastAbs(SingleCubic(m_aPerm[0], x, y, z)) * 2 - 1 };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum += (FastAbs(SingleCubic(m_aPerm[i], x, y, z)) * 2 - 1) * amp;
		}
		return sum * m_fFractalBounding;
	}

	double  CNoise::SingleCubicFractalRigidMulti(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		double sum{ 1 - FastAbs(SingleCubic(m_aPerm[0], x, y, z)) };
		double amp{1};
		int i{ 0 };
		while (++i < m_iOctaves)
		{
			x *= m_fLacunarity;
			y *= m_fLacunarity;
			z *= m_fLacunarity;
			amp *= m_fGain;
			sum -= (1 - FastAbs(SingleCubic(m_aPerm[i], x, y, z))) * amp;
		}
		return sum;
	}

	double  CNoise::SingleCubic(const unsigned char offset, const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		int x1{ FastFloor(x) };
		int y1{ FastFloor(y) };
		int z1{ FastFloor(z) };
		int x0{ x1 - 1 };
		int y0{ y1 - 1 };
		int z0{ z1 - 1 };
		int x2{ x1 + 1 };
		int y2{ y1 + 1 };
		int z2{ z1 + 1 };
		int x3{ x1 + 2 };
		int y3{ y1 + 2 };
		int z3{ z1 + 2 };
		double xs{ x - x1 };
		double ys{ y - y1 };
		double zs{ z - z1 };
		return CubicLerp(
			CubicLerp(
				CubicLerp(ValCoord3DFast(offset, x0, y0, z0), ValCoord3DFast(offset, x1, y0, z0), ValCoord3DFast(offset, x2, y0, z0), ValCoord3DFast(offset, x3, y0, z0), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y1, z0), ValCoord3DFast(offset, x1, y1, z0), ValCoord3DFast(offset, x2, y1, z0), ValCoord3DFast(offset, x3, y1, z0), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y2, z0), ValCoord3DFast(offset, x1, y2, z0), ValCoord3DFast(offset, x2, y2, z0), ValCoord3DFast(offset, x3, y2, z0), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y3, z0), ValCoord3DFast(offset, x1, y3, z0), ValCoord3DFast(offset, x2, y3, z0), ValCoord3DFast(offset, x3, y3, z0), xs),
				ys),
			CubicLerp(
				CubicLerp(ValCoord3DFast(offset, x0, y0, z1), ValCoord3DFast(offset, x1, y0, z1), ValCoord3DFast(offset, x2, y0, z1), ValCoord3DFast(offset, x3, y0, z1), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y1, z1), ValCoord3DFast(offset, x1, y1, z1), ValCoord3DFast(offset, x2, y1, z1), ValCoord3DFast(offset, x3, y1, z1), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y2, z1), ValCoord3DFast(offset, x1, y2, z1), ValCoord3DFast(offset, x2, y2, z1), ValCoord3DFast(offset, x3, y2, z1), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y3, z1), ValCoord3DFast(offset, x1, y3, z1), ValCoord3DFast(offset, x2, y3, z1), ValCoord3DFast(offset, x3, y3, z1), xs),
				ys),
			CubicLerp(
				CubicLerp(ValCoord3DFast(offset, x0, y0, z2), ValCoord3DFast(offset, x1, y0, z2), ValCoord3DFast(offset, x2, y0, z2), ValCoord3DFast(offset, x3, y0, z2), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y1, z2), ValCoord3DFast(offset, x1, y1, z2), ValCoord3DFast(offset, x2, y1, z2), ValCoord3DFast(offset, x3, y1, z2), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y2, z2), ValCoord3DFast(offset, x1, y2, z2), ValCoord3DFast(offset, x2, y2, z2), ValCoord3DFast(offset, x3, y2, z2), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y3, z2), ValCoord3DFast(offset, x1, y3, z2), ValCoord3DFast(offset, x2, y3, z2), ValCoord3DFast(offset, x3, y3, z2), xs),
				ys),
			CubicLerp(
				CubicLerp(ValCoord3DFast(offset, x0, y0, z3), ValCoord3DFast(offset, x1, y0, z3), ValCoord3DFast(offset, x2, y0, z3), ValCoord3DFast(offset, x3, y0, z3), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y1, z3), ValCoord3DFast(offset, x1, y1, z3), ValCoord3DFast(offset, x2, y1, z3), ValCoord3DFast(offset, x3, y1, z3), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y2, z3), ValCoord3DFast(offset, x1, y2, z3), ValCoord3DFast(offset, x2, y2, z3), ValCoord3DFast(offset, x3, y2, z3), xs),
				CubicLerp(ValCoord3DFast(offset, x0, y3, z3), ValCoord3DFast(offset, x1, y3, z3), ValCoord3DFast(offset, x2, y3, z3), ValCoord3DFast(offset, x3, y3, z3), xs),
				ys),
			zs) * CUBIC_3D_BOUNDING;
	}

	double  CNoise::SingleCellular(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		int xr{ FastRound(x) };
		int yr{ FastRound(y) };
		int zr{ FastRound(z) };
		double distance{ 999999 };
		int xc{ 0 }, yc{ 0 }, zc{ 0 };
		switch (m_eCellularDistance)
		{
		case CellularDistance::Euclidean:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					for (int zi = zr - 1; zi <= zr + 1; zi++)
					{
						unsigned char lutPos{ Index3D_256(0, xi, yi, zi) };
						double vecX{ xi - x + CELL_3D_X[lutPos] * m_fCellularJitter };
						double vecY{ yi - y + CELL_3D_Y[lutPos] * m_fCellularJitter };
						double vecZ{ zi - z + CELL_3D_Z[lutPos] * m_fCellularJitter };
						double newDistance{ vecX * vecX + vecY * vecY + vecZ * vecZ };
						if (newDistance < distance)
						{
							distance = newDistance;
							xc = xi;
							yc = yi;
							zc = zi;
						}
					}
				}
			}
			break;
		case CellularDistance::Manhattan:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					for (int zi = zr - 1; zi <= zr + 1; zi++)
					{
						unsigned char lutPos{ Index3D_256(0, xi, yi, zi) };
						double vecX{ xi - x + CELL_3D_X[lutPos] * m_fCellularJitter };
						double vecY{ yi - y + CELL_3D_Y[lutPos] * m_fCellularJitter };
						double vecZ{ zi - z + CELL_3D_Z[lutPos] * m_fCellularJitter };
						double newDistance{ FastAbs(vecX) + FastAbs(vecY) + FastAbs(vecZ) };
						if (newDistance < distance)
						{
							distance = newDistance;
							xc = xi;
							yc = yi;
							zc = zi;
						}
					}
				}
			}
			break;
		case CellularDistance::Natural:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					for (int zi = zr - 1; zi <= zr + 1; zi++)
					{
						unsigned char lutPos{ Index3D_256(0, xi, yi, zi) };
						double vecX{ xi - x + CELL_3D_X[lutPos] * m_fCellularJitter };
						double vecY{ yi - y + CELL_3D_Y[lutPos] * m_fCellularJitter };
						double vecZ{ zi - z + CELL_3D_Z[lutPos] * m_fCellularJitter };
						double newDistance{ (FastAbs(vecX) + FastAbs(vecY) + FastAbs(vecZ)) + (vecX * vecX + vecY * vecY + vecZ * vecZ) };
						if (newDistance < distance)
						{
							distance = newDistance;
							xc = xi;
							yc = yi;
							zc = zi;
						}
					}
				}
			}
			break;
		default:
			break;
		}

		switch (m_eCellularReturn)
		{
		case CellularReturn::CellValue:
			return ValCoord3D(m_iSeed, xc, yc, zc);
		case CellularReturn::NoiseLookup:
			if (m_pCellularNoiseLookup)
			{
				unsigned char lutPos{ Index3D_256(0, xc, yc, zc) };
				return m_pCellularNoiseLookup->CalculateNoise(xc + CELL_3D_X[lutPos] * m_fCellularJitter, yc + CELL_3D_Y[lutPos] * m_fCellularJitter, zc + CELL_3D_Z[lutPos] * m_fCellularJitter);
			}
			break;
		case CellularReturn::Distance:
			return distance;
		default:
			break;
		}
		return 0;
	}

	double  CNoise::SingleCellular2Edge(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		int xr{ FastRound(x) };
		int yr{ FastRound(y) };
		int zr{ FastRound(z) };
		double distance[4] = { 999999,999999,999999,999999 };
		switch (m_eCellularDistance)
		{
		case CellularDistance::Euclidean:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					for (int zi = zr - 1; zi <= zr + 1; zi++)
					{
						unsigned char lutPos{ Index3D_256(0, xi, yi, zi) };
						double vecX{ xi - x + CELL_3D_X[lutPos] * m_fCellularJitter };
						double vecY{ yi - y + CELL_3D_Y[lutPos] * m_fCellularJitter };
						double vecZ{ zi - z + CELL_3D_Z[lutPos] * m_fCellularJitter };
						double newDistance{ vecX * vecX + vecY * vecY + vecZ * vecZ };
						for (int i = m_iCellularDistanceIndex1; i > 0; i--)
							distance[i] = fmax(fmin(distance[i], newDistance), distance[i - 1]);
						distance[0] = fmin(distance[0], newDistance);
					}
				}
			}
			break;
		case CellularDistance::Manhattan:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					for (int zi = zr - 1; zi <= zr + 1; zi++)
					{
						unsigned char lutPos{ Index3D_256(0, xi, yi, zi) };
						double vecX{ xi - x + CELL_3D_X[lutPos] * m_fCellularJitter };
						double vecY{ yi - y + CELL_3D_Y[lutPos] * m_fCellularJitter };
						double vecZ{ zi - z + CELL_3D_Z[lutPos] * m_fCellularJitter };
						double newDistance{ FastAbs(vecX) + FastAbs(vecY) + FastAbs(vecZ) };
						for (int i = m_iCellularDistanceIndex1; i > 0; i--)
							distance[i] = fmax(fmin(distance[i], newDistance), distance[i - 1]);
						distance[0] = fmin(distance[0], newDistance);
					}
				}
			}
			break;
		case CellularDistance::Natural:
			for (int xi = xr - 1; xi <= xr + 1; xi++)
			{
				for (int yi = yr - 1; yi <= yr + 1; yi++)
				{
					for (int zi = zr - 1; zi <= zr + 1; zi++)
					{
						unsigned char lutPos{ Index3D_256(0, xi, yi, zi) };
						double vecX{ xi - x + CELL_3D_X[lutPos] * m_fCellularJitter };
						double vecY{ yi - y + CELL_3D_Y[lutPos] * m_fCellularJitter };
						double vecZ{ zi - z + CELL_3D_Z[lutPos] * m_fCellularJitter };
						double newDistance{ (FastAbs(vecX) + FastAbs(vecY) + FastAbs(vecZ)) + (vecX * vecX + vecY * vecY + vecZ * vecZ) };
						for (int i = m_iCellularDistanceIndex1; i > 0; i--)
							distance[i] = fmax(fmin(distance[i], newDistance), distance[i - 1]);
						distance[0] = fmin(distance[0], newDistance);
					}
				}
			}
			break;
		default:
			break;
		}
		switch (m_eCellularReturn)
		{
		case CellularReturn::Distance2:
			return distance[m_iCellularDistanceIndex1];
		case CellularReturn::Distance2Add:
			return distance[m_iCellularDistanceIndex1] + distance[m_iCellularDistanceIndex0];
		case CellularReturn::Distance2Sub:
			return distance[m_iCellularDistanceIndex1] - distance[m_iCellularDistanceIndex0];
		case CellularReturn::Distance2Mul:
			return distance[m_iCellularDistanceIndex1] * distance[m_iCellularDistanceIndex0];
		case CellularReturn::Distance2Div:
			return distance[m_iCellularDistanceIndex0] / distance[m_iCellularDistanceIndex1];
		default:
			return 0;
		}
	}

	void CNoise::SingleGradientPerturb(const unsigned char offset, const double warpAmp, const double frequency, double &x, double &y, double &z) const
	{
		double xf{ x * frequency };
		double yf{ y * frequency };
		double zf{ z * frequency };
		int x0{ FastFloor(xf) };
		int y0{ FastFloor(yf) };
		int z0{ FastFloor(zf) };
		int x1{ x0 + 1 };
		int y1{ y0 + 1 };
		int z1{ z0 + 1 };
		double xs{ 0 }, ys{ 0 }, zs{ 0 };
		switch (m_eInterpolationType)
		{
		default:
		case InterpolationType::Linear:
			xs = xf - x0;
			ys = yf - y0;
			zs = zf - z0;
			break;
		case InterpolationType::Hermite:
			xs = InterpHermiteFunc(xf - x0);
			ys = InterpHermiteFunc(yf - y0);
			zs = InterpHermiteFunc(zf - z0);
			break;
		case InterpolationType::Quintic:
			xs = InterpQuinticFunc(xf - x0);
			ys = InterpQuinticFunc(yf - y0);
			zs = InterpQuinticFunc(zf - z0);
			break;
		}
		int lutPos0{ Index3D_256(offset, x0, y0, z0) };
		int lutPos1{ Index3D_256(offset, x1, y0, z0) };
		double lx0x{ Lerp(CELL_3D_X[lutPos0], CELL_3D_X[lutPos1], xs) };
		double ly0x{ Lerp(CELL_3D_Y[lutPos0], CELL_3D_Y[lutPos1], xs) };
		double lz0x{ Lerp(CELL_3D_Z[lutPos0], CELL_3D_Z[lutPos1], xs) };
		lutPos0 = Index3D_256(offset, x0, y1, z0);
		lutPos1 = Index3D_256(offset, x1, y1, z0);
		double lx1x{ Lerp(CELL_3D_X[lutPos0], CELL_3D_X[lutPos1], xs) };
		double ly1x{ Lerp(CELL_3D_Y[lutPos0], CELL_3D_Y[lutPos1], xs) };
		double lz1x{ Lerp(CELL_3D_Z[lutPos0], CELL_3D_Z[lutPos1], xs) };
		double lx0y{ Lerp(lx0x, lx1x, ys) };
		double ly0y{ Lerp(ly0x, ly1x, ys) };
		double lz0y{ Lerp(lz0x, lz1x, ys) };
		lutPos0 = Index3D_256(offset, x0, y0, z1);
		lutPos1 = Index3D_256(offset, x1, y0, z1);
		lx0x = Lerp(CELL_3D_X[lutPos0], CELL_3D_X[lutPos1], xs);
		ly0x = Lerp(CELL_3D_Y[lutPos0], CELL_3D_Y[lutPos1], xs);
		lz0x = Lerp(CELL_3D_Z[lutPos0], CELL_3D_Z[lutPos1], xs);
		lutPos0 = Index3D_256(offset, x0, y1, z1);
		lutPos1 = Index3D_256(offset, x1, y1, z1);
		lx1x = Lerp(CELL_3D_X[lutPos0], CELL_3D_X[lutPos1], xs);
		ly1x = Lerp(CELL_3D_Y[lutPos0], CELL_3D_Y[lutPos1], xs);
		lz1x = Lerp(CELL_3D_Z[lutPos0], CELL_3D_Z[lutPos1], xs);
		x += Lerp(lx0y, Lerp(lx0x, lx1x, ys), zs) * warpAmp;
		y += Lerp(ly0y, Lerp(ly0x, ly1x, ys), zs) * warpAmp;
		z += Lerp(lz0y, Lerp(lz0x, lz1x, ys), zs) * warpAmp;
	}
#pragma endregion

#pragma region 4D noise helpers
	double CNoise::SingleSimplex(const unsigned char offset, const double in_x, const double in_y, const double in_z, const double in_w) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z }, w{ in_w };
		double n0, n1, n2, n3, n4;
		double t{ (x + y + z + w) * F4 };
		int i{ FastFloor(x + t) };
		int j{ FastFloor(y + t) };
		int k{ FastFloor(z + t) };
		int l{ FastFloor(w + t) };
		t = (i + j + k + l) * G4;
		double X0{ i - t };
		double Y0{ j - t };
		double Z0{ k - t };
		double W0{ l - t };
		double x0{ x - X0 };
		double y0{ y - Y0 };
		double z0{ z - Z0 };
		double w0{ w - W0 };
		int rankx{ 0 };
		int ranky{ 0 };
		int rankz{ 0 };
		int rankw{ 0 };
		if (x0 > y0)
			rankx++;
		else
			ranky++;
		if (x0 > z0)
			rankx++;
		else
			rankz++;
		if (x0 > w0)
			rankx++;
		else
			rankw++;
		if (y0 > z0)
			ranky++;
		else
			rankz++;
		if (y0 > w0)
			ranky++;
		else
			rankw++;
		if (z0 > w0)
			rankz++;
		else
			rankw++;
		int i1{ rankx >= 3 ? 1 : 0 };
		int j1{ ranky >= 3 ? 1 : 0 };
		int k1{ rankz >= 3 ? 1 : 0 };
		int l1{ rankw >= 3 ? 1 : 0 };
		int i2{ rankx >= 2 ? 1 : 0 };
		int j2{ ranky >= 2 ? 1 : 0 };
		int k2{ rankz >= 2 ? 1 : 0 };
		int l2{ rankw >= 2 ? 1 : 0 };
		int i3{ rankx >= 1 ? 1 : 0 };
		int j3{ ranky >= 1 ? 1 : 0 };
		int k3{ rankz >= 1 ? 1 : 0 };
		int l3{ rankw >= 1 ? 1 : 0 };
		double x1{ x0 - i1 + G4 };
		double y1{ y0 - j1 + G4 };
		double z1{ z0 - k1 + G4 };
		double w1{ w0 - l1 + G4 };
		double x2{ x0 - i2 + 2 * G4 };
		double y2{ y0 - j2 + 2 * G4 };
		double z2{ z0 - k2 + 2 * G4 };
		double w2{ w0 - l2 + 2 * G4 };
		double x3{ x0 - i3 + 3 * G4 };
		double y3{ y0 - j3 + 3 * G4 };
		double z3{ z0 - k3 + 3 * G4 };
		double w3{ w0 - l3 + 3 * G4 };
		double x4{ x0 - 1 + 4 * G4 };
		double y4{ y0 - 1 + 4 * G4 };
		double z4{ z0 - 1 + 4 * G4 };
		double w4{ w0 - 1 + 4 * G4 };
		t = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if (t < 0)
			n0 = 0;
		else
		{
			t *= t;
			n0 = t * t * GradCoord4D(offset, i, j, k, l, x0, y0, z0, w0);
		}
		t = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if (t < 0)
			n1 = 0;
		else
		{
			t *= t;
			n1 = t * t * GradCoord4D(offset, i + i1, j + j1, k + k1, l + l1, x1, y1, z1, w1);
		}
		t = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if (t < 0)
			n2 = 0;
		else
		{
			t *= t;
			n2 = t * t * GradCoord4D(offset, i + i2, j + j2, k + k2, l + l2, x2, y2, z2, w2);
		}
		t = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if (t < 0)
			n3 = 0;
		else
		{
			t *= t;
			n3 = t * t * GradCoord4D(offset, i + i3, j + j3, k + k3, l + l3, x3, y3, z3, w3);
		}
		t = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if (t < 0)
			n4 = 0;
		else
		{
			t *= t;
			n4 = t * t * GradCoord4D(offset, i + 1, j + 1, k + 1, l + 1, x4, y4, z4, w4);
		}
		return 27 * (n0 + n1 + n2 + n3 + n4);
	}
#pragma endregion

#pragma region Noise
	double CNoise::CalculateNoise(const double in_x, const double in_y) const
	{
		double x{ in_x * m_fFrequency }, y{ in_y * m_fFrequency };
		switch (m_eNoiseType)
		{
		case NoiseType::Value:
			return SingleValue(0, x, y);
		case NoiseType::ValueFractal:
			switch (m_eFractalType)
			{
			case FractalType::FBM:
				return SingleValueFractalFBM(x, y);
			case FractalType::Billow:
				return SingleValueFractalBillow(x, y);
			case FractalType::RigidMulti:
				return SingleValueFractalRigidMulti(x, y);
			}
		case NoiseType::Perlin:
			return SinglePerlin(0, x, y);
		case NoiseType::PerlinFractal:
			switch (m_eFractalType)
			{
			case FractalType::FBM:
				return SinglePerlinFractalFBM(x, y);
			case FractalType::Billow:
				return SinglePerlinFractalBillow(x, y);
			case FractalType::RigidMulti:
				return SinglePerlinFractalRigidMulti(x, y);
			}
		case NoiseType::Simplex:
			return SingleSimplex(0, x, y);
		case NoiseType::SimplexFractal:
			switch (m_eFractalType)
			{
			case FractalType::FBM:
				return SingleSimplexFractalFBM(x, y);
			case FractalType::Billow:
				return SingleSimplexFractalBillow(x, y);
			case FractalType::RigidMulti:
				return SingleSimplexFractalRigidMulti(x, y);
			}
		case NoiseType::Cellular:
			switch (m_eCellularReturn)
			{
			case CellularReturn::CellValue:
			case CellularReturn::NoiseLookup:
			case CellularReturn::Distance:
				return SingleCellular(x, y);
			default:
				return SingleCellular2Edge(x, y);
			}
		case NoiseType::White:
			return CalculateWhiteNoise(x, y);
		case NoiseType::Cubic:
			return SingleCubic(0, x, y);
		case NoiseType::CubicFractal:
			switch (m_eFractalType)
			{
			case FractalType::FBM:
				return SingleCubicFractalFBM(x, y);
			case FractalType::Billow:
				return SingleCubicFractalBillow(x, y);
			case FractalType::RigidMulti:
				return SingleCubicFractalRigidMulti(x, y);
			}
		}
		return 0;
	}

	double CNoise::CalculateNoise(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x * m_fFrequency }, y{ in_y * m_fFrequency }, z{ in_z * m_fFrequency };
		switch (m_eNoiseType)
		{
		case NoiseType::Value:
			return SingleValue(0, x, y, z);
		case NoiseType::ValueFractal:
			switch (m_eFractalType)
			{
			case FractalType::FBM:
				return SingleValueFractalFBM(x, y, z);
			case FractalType::Billow:
				return SingleValueFractalBillow(x, y, z);
			case FractalType::RigidMulti:
				return SingleValueFractalRigidMulti(x, y, z);
			default:
				return 0;
			}
		case NoiseType::Perlin:
			return SinglePerlin(0, x, y, z);
		case NoiseType::PerlinFractal:
			switch (m_eFractalType)
			{
			case FractalType::FBM:
				return SinglePerlinFractalFBM(x, y, z);
			case FractalType::Billow:
				return SinglePerlinFractalBillow(x, y, z);
			case FractalType::RigidMulti:
				return SinglePerlinFractalRigidMulti(x, y, z);
			default:
				return 0;
			}
		case NoiseType::Simplex:
			return SingleSimplex(0, x, y, z);
		case NoiseType::SimplexFractal:
			switch (m_eFractalType)
			{
			case FractalType::FBM:
				return SingleSimplexFractalFBM(x, y, z);
			case FractalType::Billow:
				return SingleSimplexFractalBillow(x, y, z);
			case FractalType::RigidMulti:
				return SingleSimplexFractalRigidMulti(x, y, z);
			default:
				return 0;
			}
		case NoiseType::Cellular:
			switch (m_eCellularReturn)
			{
			case CellularReturn::CellValue:
			case CellularReturn::NoiseLookup:
			case CellularReturn::Distance:
				return SingleCellular(x, y, z);
			default:
				return SingleCellular2Edge(x, y, z);
			}
		case NoiseType::White:
			return CalculateWhiteNoise(x, y, z);
		case NoiseType::Cubic:
			return SingleCubic(0, x, y, z);
		case NoiseType::CubicFractal:
			switch (m_eFractalType)
			{
			case FractalType::FBM:
				return SingleCubicFractalFBM(x, y, z);
			case FractalType::Billow:
				return SingleCubicFractalBillow(x, y, z);
			case FractalType::RigidMulti:
				return SingleCubicFractalRigidMulti(x, y, z);
			}
		default:
			return 0;
		}
	}
#pragma endregion

#pragma region White noise
	double CNoise::CalculateWhiteNoise(const double in_x, const double in_y) const
	{
		double x{ in_x }, y{ in_y };
		return ValCoord2D(m_iSeed,
			*reinterpret_cast<int*>(&x) ^ (*reinterpret_cast<int*>(&x) >> 16),
			*reinterpret_cast<int*>(&y) ^ (*reinterpret_cast<int*>(&y) >> 16));
	}

	double CNoise::CalculateWhiteNoiseInt(const int x, const int y) const
	{
		return ValCoord2D(m_iSeed, x, y);
	}

	double CNoise::CalculateWhiteNoise(const double in_x, const double in_y, const double in_z) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z };
		return ValCoord3D(m_iSeed,
			*reinterpret_cast<int*>(&x) ^ (*reinterpret_cast<int*>(&x) >> 16),
			*reinterpret_cast<int*>(&y) ^ (*reinterpret_cast<int*>(&y) >> 16),
			*reinterpret_cast<int*>(&z) ^ (*reinterpret_cast<int*>(&z) >> 16));
	}

	double CNoise::CalculateWhiteNoiseInt(const int x, const int y, const int z) const
	{
		return ValCoord3D(m_iSeed, x, y, z);
	}

	double CNoise::CalculateWhiteNoise(const double in_x, const double in_y, const double in_z, const double in_w) const
	{
		double x{ in_x }, y{ in_y }, z{ in_z }, w{ in_w };
		return ValCoord4D(m_iSeed,
			*reinterpret_cast<int*>(&x) ^ (*reinterpret_cast<int*>(&x) >> 16),
			*reinterpret_cast<int*>(&y) ^ (*reinterpret_cast<int*>(&y) >> 16),
			*reinterpret_cast<int*>(&z) ^ (*reinterpret_cast<int*>(&z) >> 16),
			*reinterpret_cast<int*>(&w) ^ (*reinterpret_cast<int*>(&w) >> 16));
	}

	double CNoise::CalculateWhiteNoiseInt(const int x, const int y, const int z, const int w) const
	{
		return ValCoord4D(m_iSeed, x, y, z, w);
	}
#pragma endregion

#pragma region Value noise
	double CNoise::CalculateValue(const double x, const double y) const
	{
		return SingleValue(0, x * m_fFrequency, y * m_fFrequency);
	}

	double CNoise::CalculateValueFractal(const double x, const double y) const
	{
		switch (m_eFractalType)
		{
		case FractalType::FBM:
			return SingleValueFractalFBM(x * m_fFrequency, y * m_fFrequency);
		case FractalType::Billow:
			return SingleValueFractalBillow(x * m_fFrequency, y * m_fFrequency);
		case FractalType::RigidMulti:
			return SingleValueFractalRigidMulti(x * m_fFrequency, y * m_fFrequency);
		default:
			return 0;
		}
	}

	double CNoise::CalculateValue(const double x, const double y, const double z) const
	{
		return SingleValue(0, x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
	}

	double CNoise::CalculateValueFractal(const double x, const double y, const double z) const
	{
		switch (m_eFractalType)
		{
		case FractalType::FBM:
			return SingleValueFractalFBM(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		case FractalType::Billow:
			return SingleValueFractalBillow(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		case FractalType::RigidMulti:
			return SingleValueFractalRigidMulti(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		default:
			return 0;
		}
	}
#pragma endregion

#pragma region Perlin noise
	double CNoise::CalculatePerlin(const double x, const double y) const
	{
		return SinglePerlin(0, x * m_fFrequency, y * m_fFrequency);
	}

	double CNoise::CalculatePerlinFractal(const double x, const double y) const
	{
		switch (m_eFractalType)
		{
		case FractalType::FBM:
			return SinglePerlinFractalFBM(x * m_fFrequency, y * m_fFrequency);
		case FractalType::Billow:
			return SinglePerlinFractalBillow(x * m_fFrequency, y * m_fFrequency);
		case FractalType::RigidMulti:
			return SinglePerlinFractalRigidMulti(x * m_fFrequency, y * m_fFrequency);
		default:
			return 0;
		}
	}

	double CNoise::CalculatePerlin(const double x, const double y, const double z) const
	{
		return SinglePerlin(0, x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
	}

	double CNoise::CalculatePerlinFractal(const double x, const double y, const double z) const
	{
		switch (m_eFractalType)
		{
		case FractalType::FBM:
			return SinglePerlinFractalFBM(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		case FractalType::Billow:
			return SinglePerlinFractalBillow(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		case FractalType::RigidMulti:
			return SinglePerlinFractalRigidMulti(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		default:
			return 0;
		}
	}
#pragma endregion

#pragma region Simplex noise
	double CNoise::CalculateSimplex(const double x, const double y) const
	{
		return SingleSimplex(0, x * m_fFrequency, y * m_fFrequency);
	}

	double CNoise::CalculateSimplexFractal(const double x, const double y) const
	{
		switch (m_eFractalType)
		{
		case FractalType::FBM:
			return SingleSimplexFractalFBM(x * m_fFrequency, y * m_fFrequency);
		case FractalType::Billow:
			return SingleSimplexFractalBillow(x * m_fFrequency, y * m_fFrequency);
		case FractalType::RigidMulti:
			return SingleSimplexFractalRigidMulti(x * m_fFrequency, y * m_fFrequency);
		default:
			return 0;
		}
	}

	double CNoise::CalculateSimplex(const double x, const double y, const double z) const
	{
		return SingleSimplex(0, x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
	}

	double CNoise::CalculateSimplexFractal(const double x, const double y, const double z) const
	{
		switch (m_eFractalType)
		{
		case FractalType::FBM:
			return SingleSimplexFractalFBM(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		case FractalType::Billow:
			return SingleSimplexFractalBillow(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		case FractalType::RigidMulti:
			return SingleSimplexFractalRigidMulti(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		default:
			return 0;
		}
	}

	double CNoise::CalculateSimplex(const double x, const double y, const double z, const double w) const
	{
		return SingleSimplex(0, x * m_fFrequency, y * m_fFrequency, z * m_fFrequency, w * m_fFrequency);
	}
#pragma endregion

#pragma region Cubic noise
	double CNoise::CalculateCubic(const double x, const double y) const
	{
		return SingleCubic(0, x * m_fFrequency, y * m_fFrequency);
	}

	double CNoise::CalculateCubicFractal(const double x, const double y) const
	{
		switch (m_eFractalType)
		{
		case FractalType::FBM:
			return SingleCubicFractalFBM(x * m_fFrequency, y * m_fFrequency);
		case FractalType::Billow:
			return SingleCubicFractalBillow(x * m_fFrequency, y * m_fFrequency);
		case FractalType::RigidMulti:
			return SingleCubicFractalRigidMulti(x * m_fFrequency, y * m_fFrequency);
		default:
			return 0;
		}
	}

	double CNoise::CalculateCubic(const double x, const double y, const double z) const
	{
		return SingleCubic(0, x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
	}

	double CNoise::CalculateCubicFractal(const double x, const double y, const double z) const
	{
		switch (m_eFractalType)
		{
		case FractalType::FBM:
			return SingleCubicFractalFBM(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		case FractalType::Billow:
			return SingleCubicFractalBillow(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		case FractalType::RigidMulti:
			return SingleCubicFractalRigidMulti(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		default:
			return 0;
		}
	}
#pragma endregion

#pragma region Cellular noise
	double CNoise::CalculateCellular(const double x, const double y) const
	{
		switch (m_eCellularReturn)
		{
		case CellularReturn::CellValue:
		case CellularReturn::NoiseLookup:
		case CellularReturn::Distance:
			return SingleCellular(x * m_fFrequency, y * m_fFrequency);
		default:
			return SingleCellular2Edge(x * m_fFrequency, y * m_fFrequency);
		}
	}

	double CNoise::CalculateCellular(const double x, const double y, const double z) const
	{
		switch (m_eCellularReturn)
		{
		case CellularReturn::CellValue:
		case CellularReturn::NoiseLookup:
		case CellularReturn::Distance:
			return SingleCellular(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		default:
			return SingleCellular2Edge(x * m_fFrequency, y * m_fFrequency, z * m_fFrequency);
		}
	}
#pragma endregion

#pragma region Gradient perturb
	void CNoise::GradientPerturb(double &x, double &y) const
	{
		SingleGradientPerturb(0, m_fGradientPerturbAmplitude, m_fFrequency, x, y);
	}

	void CNoise::GradientPerturbFractal(double &x, double &y) const
	{
		double amp{m_fGradientPerturbAmplitude * m_fFractalBounding};
		double freq{ m_fFrequency };
		int i{ 0 };
		SingleGradientPerturb(m_aPerm[0], amp, m_fFrequency, x, y);
		while (++i < m_iOctaves)
		{
			freq *= m_fLacunarity;
			amp *= m_fGain;
			SingleGradientPerturb(m_aPerm[i], amp, freq, x, y);
		}
	}

	void CNoise::GradientPerturb(double &x, double &y, double &z) const
	{
		SingleGradientPerturb(0, m_fGradientPerturbAmplitude, m_fFrequency, x, y, z);
	}

	void CNoise::GradientPerturbFractal(double &x, double &y, double &z) const
	{
		double amp{m_fGradientPerturbAmplitude * m_fFractalBounding};
		double freq{ m_fFrequency };
		int i{ 0 };
		SingleGradientPerturb(m_aPerm[0], amp, m_fFrequency, x, y, z);
		while (++i < m_iOctaves)
		{
			freq *= m_fLacunarity;
			amp *= m_fGain;
			SingleGradientPerturb(m_aPerm[i], amp, freq, x, y, z);
		}
	}
#pragma endregion
}