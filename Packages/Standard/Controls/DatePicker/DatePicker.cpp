// This file is a part of Nitisa framework
// Copyright © 2022 Nitisa. All rights reserved.
// Author: Dimitry Lysenko
// Site: http://nitisa.com
// Download: http://nitisa.com/downloads
// Documentation: http://nitisa.com/documentation
// License: http://nitisa.com/site/license

#include "stdafx.h"

namespace nitisa
{
	namespace standard
	{
		const int IconWidth{ 16 };
		const int IconHeight{ 16 };
		const Color IconData[16 * 16]{
			{ 131, 170,  89, 150 }, { 128, 167,  86, 255 }, { 125, 163,  82, 255 }, { 121, 158,  78, 255 }, { 116, 153,  73, 255 }, { 111, 147,  67, 255 }, { 105, 140,  61, 255 }, { 100, 134,  55, 255 }, {  94, 127,  49, 255 }, {  88, 120,  43, 255 }, {  83, 114,  37, 255 }, {  77, 107,  31, 255 }, {  72, 101,  25, 255 }, {  67,  96,  20, 255 }, {  63,  91,  16, 255 }, {  60,  87,  12, 150 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 205, 122, 100, 255 }, { 205, 122, 100, 255 }, { 205, 122, 100, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 205, 122, 100, 255 }, { 255, 255, 255, 255 }, { 205, 122, 100, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 205, 122, 100, 255 }, { 205, 122, 100, 255 }, { 205, 122, 100, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 204, 204, 204, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 255 }, { 179, 202, 154, 255 }, { 128, 167,  86, 255 }, {  95, 129,  51, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, { 255, 255, 255, 255 }, {  60,  87,  12, 255 },
			{ 131, 170,  89, 150 }, { 128, 167,  86, 255 }, { 125, 163,  82, 255 }, { 121, 158,  78, 255 }, { 116, 153,  73, 255 }, { 111, 147,  67, 255 }, { 105, 140,  61, 255 }, { 100, 134,  55, 255 }, {  94, 127,  49, 255 }, {  88, 120,  43, 255 }, {  83, 114,  37, 255 }, {  77, 107,  31, 255 }, {  72, 101,  25, 255 }, {  67,  96,  20, 255 }, {  63,  91,  16, 255 }, {  60,  87,  12, 150 },
			{ 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 }, { 255, 255, 255,   0 },
		};

		const Image CDatePicker::m_cIcon{ IconWidth, IconHeight, IconData };

	#pragma region CTimerListener
		CDatePicker::CTimerListener::CTimerListener(CDatePicker *control) :
			m_pControl{ control }
		{

		}

		void CDatePicker::CTimerListener::NotifyOnTimer(const PlatformHandle id)
		{
			if (m_pControl->m_eDownElement == Element::UpArrow)
			{
				switch (m_pControl->m_eActiveElement)
				{
				case Element::Years:
					m_pControl->setYear(m_pControl->getYear() + 1);
					break;
				case Element::Months:
					m_pControl->setMonth(m_pControl->getMonth() + 1);
					break;
				case Element::Days:
					m_pControl->setDay(m_pControl->getDay() + 1);
					break;
				default:
					break;
				}
			}
			else if (m_pControl->m_eDownElement == Element::DownArrow)
			{
				switch (m_pControl->m_eActiveElement)
				{
				case Element::Years:
					m_pControl->setYear(m_pControl->getYear() - 1);
					break;
				case Element::Months:
					m_pControl->setMonth(m_pControl->getMonth() - 1);
					break;
				case Element::Days:
					m_pControl->setDay(m_pControl->getDay() - 1);
					break;
				default:
					break;
				}
			}
		}
	#pragma endregion

	#pragma region CGradientListener
		CDatePicker::CGradientListener::CGradientListener(CDatePicker *control) :
			m_pControl{ control }
		{

		}

		void CDatePicker::CGradientListener::NotifyOnChange()
		{
			if (!m_pControl->m_bIgnoreGradient)
			{
				if (m_pControl->m_pCanvas)
					m_pControl->m_pCanvas->setValid(false);
				if (m_pControl->m_bOpened && m_pControl->m_pCanvasCalendar)
					m_pControl->m_pCanvasCalendar->setValid(false);
				m_pControl->Repaint(false);
			}
		}
	#pragma endregion

	#pragma region Constructor & destructor
		CDatePicker::CDatePicker():
			CControl(L"DatePicker", true, true, false, true, false, true),
			m_cGradientListener{ this },
			m_eDisplayMode{ DisplayMode::DropDown },
			m_eMonthFormat{ MonthFormat::Short },
			m_eElementOrder{ ElementOrder::DayMonthYear },
			m_eOpenDirection{ OpenDirection::Auto },
			m_eOpenAlign{ OpenAlign::Right },
			m_sSeparator1{ L"." },
			m_sSeparator2{ L"." },
			m_bShowDayLeadingZeros{ true },
			m_bShowMonthLeadingZeros{ true },
			m_bShowYearLeadingZeros{ true },
			m_bShowIcon{ true },
			m_fTimerInterval{ ScrollInterval },
			m_eContentAlign{ TextAlign::Left },
			m_bArrowsAtRight{ true },
			// Control background
			m_aShadowRadius{ 1, 1, 1, 1, 1, 1, 1 },
			m_aShadowShift{
				PointF{ 0, 0 },
				PointF{ 0, 0 },
				PointF{ 0, 0 }, PointF{ 0, 0 },
				PointF{ 0, 0 },
				PointF{ 0, 0 },
				PointF{ 0, 0 } },
			m_aShadowColor{
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 } },
			m_aBorderRadius{
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 } },
			m_aOuterBorderWidth{
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 } },
			m_aOuterBorderColor{
				BorderColor{ Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 } },
				BorderColor{ Color{ 87, 148, 191, 255 }, Color{ 87, 148, 191, 255 }, Color{ 87, 148, 191, 255 }, Color{ 87, 148, 191, 255 } },
				BorderColor{ Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 } },
				BorderColor{ Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 } },
				BorderColor{ Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 } },
				BorderColor{ Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 }, Color{ 61, 123, 173, 255 } },
				BorderColor{ Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 } } },
			m_aInnerBorderWidth{
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 } },
			m_aInnerBorderColor{
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } } },
			m_aBackgroundColor{
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 } },
			m_aBackgroundGradient{
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener } },
			// UpDown's Up arrow
			m_aUpArrowBorderRadius{
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 } },
			m_aUpArrowOuterBorderWidth{
				RectF{ 1, 1, 1, 0 },
				RectF{ 1, 1, 1, 0 },
				RectF{ 1, 1, 1, 0 },
				RectF{ 1, 1, 1, 0 },
				RectF{ 1, 1, 1, 0 },
				RectF{ 1, 1, 1, 0 },
				RectF{ 1, 1, 1, 0 } },
			m_aUpArrowInnerBorderWidth{
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 } },
			m_aUpArrowOuterBorderColor{
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } } },
			m_aUpArrowInnerBorderColor{
				BorderColor{ Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 } },
				BorderColor{ Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 } },
				BorderColor{ Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 } },
				BorderColor{ Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 } },
				BorderColor{ Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 } },
				BorderColor{ Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 } },
				BorderColor{ Color{ 191, 191, 191, 255 }, Color{ 191, 191, 191, 255 }, Color{ 191, 191, 191, 255 }, Color{ 191, 191, 191, 255 } } },
			m_aUpArrowBackgroundColor{
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 238, 238, 238, 255 } },
			m_aUpArrowBackgroundGradient{
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener } },
			m_aUpArrowPadding{
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 } },
			m_aUpArrowColor1{
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 159, 160, 165, 255 } },
			m_aUpArrowColor2{
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 159, 160, 165, 255 } },
			m_aUpArrowColor3{
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 159, 160, 165, 255 } },
			// UpDown's Down arrow
			m_aDownArrowBorderRadius{
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 } },
			m_aDownArrowOuterBorderWidth{
				RectF{ 1, 0, 1, 1 },
				RectF{ 1, 0, 1, 1 },
				RectF{ 1, 0, 1, 1 },
				RectF{ 1, 0, 1, 1 },
				RectF{ 1, 0, 1, 1 },
				RectF{ 1, 0, 1, 1 },
				RectF{ 1, 0, 1, 1 } },
			m_aDownArrowInnerBorderWidth{
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 },
				RectF{ 1, 1, 1, 1 } },
			m_aDownArrowOuterBorderColor{
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } },
				BorderColor{ Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 }, Color{ 255, 255, 255, 255 } } },
			m_aDownArrowInnerBorderColor{
				BorderColor{ Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 } },
				BorderColor{ Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 } },
				BorderColor{ Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 }, Color{ 171, 173, 179, 255 } },
				BorderColor{ Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 }, Color{ 60, 127, 177, 255 } },
				BorderColor{ Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 } },
				BorderColor{ Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 }, Color{ 44, 98, 139, 255 } },
				BorderColor{ Color{ 191, 191, 191, 255 }, Color{ 191, 191, 191, 255 }, Color{ 191, 191, 191, 255 }, Color{ 191, 191, 191, 255 } } },
			m_aDownArrowBackgroundColor{
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 238, 238, 238, 255 } },
			m_aDownArrowBackgroundGradient{
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener } },
			m_aDownArrowPadding{
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 },
				RectF{ 3, 1, 3, 1 } },
			m_aDownArrowColor1{
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 159, 160, 165, 255 } },
			m_aDownArrowColor2{
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 159, 160, 165, 255 } },
			m_aDownArrowColor3{
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 95, 110, 165, 255 },
				Color{ 159, 160, 165, 255 } },
			m_aArrowDistance{ 1, 1, 1, 1, 1, 1, 1 },
			// DropDown's arrow
			m_aArrowBorderRadius{
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 } },
			m_aArrowOuterBorderWidth{
				RectF{ 1, 0, 0, 0 },
				RectF{ 1, 0, 0, 0 },
				RectF{ 1, 0, 0, 0 },
				RectF{ 1, 0, 0, 0 },
				RectF{ 1, 0, 0, 0 },
				RectF{ 1, 0, 0, 0 },
				RectF{ 1, 0, 0, 0 } },
			m_aArrowInnerBorderWidth{
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 },
				RectF{ 0, 0, 0, 0 } },
			m_aArrowOuterBorderColor{
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 87, 148, 191, 255 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 87, 148, 191, 255 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 87, 148, 191, 255 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 87, 148, 191, 255 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 87, 148, 191, 255 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } } },
			m_aArrowInnerBorderColor{
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } },
				BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 255 } } },
			m_aArrowBackgroundColor{
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 } },
			m_aArrowBackgroundGradient{
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener } },
			m_aArrowPadding{
				RectF{ 5, 8, 5, 7 },
				RectF{ 5, 8, 5, 7 },
				RectF{ 5, 8, 5, 7 },
				RectF{ 5, 8, 5, 7 },
				RectF{ 5, 8, 5, 7 },
				RectF{ 5, 8, 5, 7 },
				RectF{ 5, 8, 5, 7 } },
			m_aArrowColor1{
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 109, 109, 109, 255 } },
			m_aArrowColor2{
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 109, 109, 109, 255 } },
			m_aArrowColor3{
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 0, 0, 0, 255 },
				Color{ 109, 109, 109, 109 } },
			// DropDown's icon
			m_pImageList{ nullptr },
			m_aIconIndex{ -1, -1, -1, -1, -1, -1, -1 },
			m_aIconPadding{
				RectF{ 4, 3, 3, 0 },
				RectF{ 4, 3, 3, 0 },
				RectF{ 4, 3, 3, 0 },
				RectF{ 4, 3, 3, 0 },
				RectF{ 4, 3, 3, 0 },
				RectF{ 4, 3, 3, 0 },
				RectF{ 4, 3, 3, 0 } },
			// Element
			m_aElementBackgroundColor{
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 255, 32 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 255, 32 },
				Color{ 0, 0, 255, 255 },
				Color{ 0, 0, 255, 255 },
				Color{ 0, 0, 0, 0 } },
			m_aElementBackgroundGradient{
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener },
				Gradient{ &m_cGradientListener } },
			m_aElementColor{
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 0, 0, 0, 0 },
				Color{ 255, 255, 255, 255 },
				Color{ 255, 255, 255, 255 },
				Color{ 0, 0, 0, 0 } },
			m_aElementPadding{ 2, 2, 2, 2, 2, 2, 2 },
			// Calendar
			m_fCalendarMargin{ 0 },
			m_sCalendarOuterBorderWidth{ 1, 1, 1, 1 },
			m_sCalendarInnerBorderWidth{ 0, 0, 0, 0 },
			m_sCalendarPadding{ 5, 3, 5, 3 },
			m_iCalendarShadowRadius{ 1 },
			m_sCalendarShadowShift{ 0, 0 },
			m_sCalendarShadowColor{ 0, 0, 0, 0 },
			m_sCalendarBorderRadius{ 0, 0, 0, 0 },
			m_sCalendarOuterBorderColor{ Color{ 151, 151, 151, 255 }, Color{ 151, 151, 151, 255 }, Color{ 151, 151, 151, 255 }, Color{ 151, 151, 151, 255 } },
			m_sCalendarInnerBorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } },
			m_sCalendarBackgroundColor{ 255, 255, 255, 255 },
			m_cCalendarBackgroundGradient{ &m_cGradientListener },
			// Internal
			m_pCanvas{ nullptr },
			m_pCanvasCalendar{ nullptr },
			m_bIgnoreGradient{ true },
			m_eActiveElement{ Element::Days },
			m_eHoveredElement{ Element::None },
			m_eDownElement{ Element::None },
			m_pMonthCalendar{ nullptr },
			m_cListener{ this },
			m_hTimer{ nullptr },
			m_bOpened{ false },
			m_bFirstDigit{ true },
			m_cTimerListener{ this }
		{
			OnChange = nullptr;
			setService(new CDatePickerService(this), true);

			m_aUpArrowBackgroundGradient[(int)State::Normal].setPointCount(3);
			m_aUpArrowBackgroundGradient[(int)State::Normal].setPoint(0, Color1D{ 0.0f, Color{ 242, 242, 242, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Normal].setPoint(1, Color1D{ 0.7f, Color{ 232, 232, 232, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Normal].setPoint(2, Color1D{ 1.0f, Color{ 209, 209, 209, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Hovered].setPointCount(3);
			m_aUpArrowBackgroundGradient[(int)State::Hovered].setPoint(0, Color1D{ 0.0f, Color{ 233, 236, 253, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Hovered].setPoint(1, Color1D{ 0.7f, Color{ 210, 237, 252, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Hovered].setPoint(2, Color1D{ 1.0f, Color{ 169, 219, 245, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Focused].setPointCount(3);
			m_aUpArrowBackgroundGradient[(int)State::Focused].setPoint(0, Color1D{ 0.0f, Color{ 242, 242, 242, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Focused].setPoint(1, Color1D{ 0.7f, Color{ 232, 232, 232, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Focused].setPoint(2, Color1D{ 1.0f, Color{ 209, 209, 209, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::FocusedHovered].setPointCount(3);
			m_aUpArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(0, Color1D{ 0.0f, Color{ 233, 236, 253, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(1, Color1D{ 0.7f, Color{ 210, 237, 252, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(2, Color1D{ 1.0f, Color{ 169, 219, 245, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Active].setPointCount(4);
			m_aUpArrowBackgroundGradient[(int)State::Active].setPoint(0, Color1D{ 0.0f, Color{ 166, 199, 217, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Active].setPoint(1, Color1D{ 0.3f, Color{ 194, 228, 246, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Active].setPoint(2, Color1D{ 0.7f, Color{ 194, 228, 246, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::Active].setPoint(3, Color1D{ 1.0f, Color{ 145, 204, 235, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::ActiveHovered].setPointCount(4);
			m_aUpArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(0, Color1D{ 0.0f, Color{ 166, 199, 217, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(1, Color1D{ 0.3f, Color{ 194, 228, 246, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(2, Color1D{ 0.7f, Color{ 194, 228, 246, 255 } });
			m_aUpArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(3, Color1D{ 1.0f, Color{ 145, 204, 235, 255 } });

			m_aDownArrowBackgroundGradient[(int)State::Normal].setPointCount(3);
			m_aDownArrowBackgroundGradient[(int)State::Normal].setPoint(0, Color1D{ 0.0f, Color{ 242, 242, 242, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Normal].setPoint(1, Color1D{ 0.7f, Color{ 232, 232, 232, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Normal].setPoint(2, Color1D{ 1.0f, Color{ 209, 209, 209, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Hovered].setPointCount(3);
			m_aDownArrowBackgroundGradient[(int)State::Hovered].setPoint(0, Color1D{ 0.0f, Color{ 233, 236, 253, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Hovered].setPoint(1, Color1D{ 0.7f, Color{ 210, 237, 252, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Hovered].setPoint(2, Color1D{ 1.0f, Color{ 169, 219, 245, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Focused].setPointCount(3);
			m_aDownArrowBackgroundGradient[(int)State::Focused].setPoint(0, Color1D{ 0.0f, Color{ 242, 242, 242, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Focused].setPoint(1, Color1D{ 0.7f, Color{ 232, 232, 232, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Focused].setPoint(2, Color1D{ 1.0f, Color{ 209, 209, 209, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::FocusedHovered].setPointCount(3);
			m_aDownArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(0, Color1D{ 0.0f, Color{ 233, 236, 253, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(1, Color1D{ 0.7f, Color{ 210, 237, 252, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(2, Color1D{ 1.0f, Color{ 169, 219, 245, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Active].setPointCount(4);
			m_aDownArrowBackgroundGradient[(int)State::Active].setPoint(0, Color1D{ 0.0f, Color{ 166, 199, 217, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Active].setPoint(1, Color1D{ 0.3f, Color{ 194, 228, 246, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Active].setPoint(2, Color1D{ 0.7f, Color{ 194, 228, 246, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::Active].setPoint(3, Color1D{ 1.0f, Color{ 145, 204, 235, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::ActiveHovered].setPointCount(4);
			m_aDownArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(0, Color1D{ 0.0f, Color{ 166, 199, 217, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(1, Color1D{ 0.3f, Color{ 194, 228, 246, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(2, Color1D{ 0.7f, Color{ 194, 228, 246, 255 } });
			m_aDownArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(3, Color1D{ 1.0f, Color{ 145, 204, 235, 255 } });

			m_aArrowBackgroundGradient[(int)State::Hovered].setPointCount(4);
			m_aArrowBackgroundGradient[(int)State::Hovered].setPoint(0, Color1D{ 0.000f,Color { 234, 246, 253, 255 } });
			m_aArrowBackgroundGradient[(int)State::Hovered].setPoint(1, Color1D{ 0.499f,Color { 217, 240, 252, 255 } });
			m_aArrowBackgroundGradient[(int)State::Hovered].setPoint(2, Color1D{ 0.500f,Color { 190, 230, 253, 255 } });
			m_aArrowBackgroundGradient[(int)State::Hovered].setPoint(3, Color1D{ 1.000f,Color { 167, 217, 245, 255 } });
			m_aArrowBackgroundGradient[(int)State::Focused].setPointCount(4);
			m_aArrowBackgroundGradient[(int)State::Focused].setPoint(0, Color1D{ 0.000f, Color{ 222, 237, 246, 255 } });
			m_aArrowBackgroundGradient[(int)State::Focused].setPoint(1, Color1D{ 0.499f, Color{ 196, 229, 246, 255 } });
			m_aArrowBackgroundGradient[(int)State::Focused].setPoint(2, Color1D{ 0.500f, Color{ 152, 209, 239, 255 } });
			m_aArrowBackgroundGradient[(int)State::Focused].setPoint(3, Color1D{ 1.000f, Color{ 102, 175, 215, 255 } });
			m_aArrowBackgroundGradient[(int)State::FocusedHovered].setPointCount(4);
			m_aArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(0, Color1D{ 0.000f, Color{ 222, 237, 246, 255 } });
			m_aArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(1, Color1D{ 0.499f, Color{ 196, 229, 246, 255 } });
			m_aArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(2, Color1D{ 0.500f, Color{ 152, 209, 239, 255 } });
			m_aArrowBackgroundGradient[(int)State::FocusedHovered].setPoint(3, Color1D{ 1.000f, Color{ 102, 175, 215, 255 } });
			m_aArrowBackgroundGradient[(int)State::Active].setPointCount(4);
			m_aArrowBackgroundGradient[(int)State::Active].setPoint(0, Color1D{ 0.000f, Color{ 222, 237, 246, 255 } });
			m_aArrowBackgroundGradient[(int)State::Active].setPoint(1, Color1D{ 0.499f, Color{ 196, 229, 246, 255 } });
			m_aArrowBackgroundGradient[(int)State::Active].setPoint(2, Color1D{ 0.500f, Color{ 152, 209, 239, 255 } });
			m_aArrowBackgroundGradient[(int)State::Active].setPoint(3, Color1D{ 1.000f, Color{ 102, 175, 215, 255 } });
			m_aArrowBackgroundGradient[(int)State::ActiveHovered].setPointCount(4);
			m_aArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(0, Color1D{ 0.000f, Color{ 222, 237, 246, 255 } });
			m_aArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(1, Color1D{ 0.499f, Color{ 196, 229, 246, 255 } });
			m_aArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(2, Color1D{ 0.500f, Color{ 152, 209, 239, 255 } });
			m_aArrowBackgroundGradient[(int)State::ActiveHovered].setPoint(3, Color1D{ 1.000f, Color{ 102, 175, 215, 255 } });

			setSize(PointF{ 120, 21 });
			m_bIgnoreGradient = false;
		}

		CDatePicker::CDatePicker(IForm *parent):CDatePicker()
		{
			setForm(parent);
		}

		CDatePicker::CDatePicker(IControl *parent) : CDatePicker()
		{
			setParent(parent);
		}

		CDatePicker::~CDatePicker()
		{
			if (m_pMonthCalendar)
				m_pMonthCalendar->Release();
		}
	#pragma endregion

	#pragma region IControl getters
		IControl * CDatePicker::getControl(const int index)
		{
			return nullptr;
		}

		IControl *CDatePicker::getControl(const String &name)
		{
			return nullptr;
		}

		IControl *CDatePicker::getControl(const PointF &position)
		{
			if (m_bOpened)
			{
				Vec4f v{ ntl::Inversed<float>(getTransformMatrix()) * Vec4f{ position.X, position.Y, 0, 1 } };
				if (v.X >= m_sCalendarRect.Left && v.X < m_sCalendarRect.Right && v.Y >= m_sCalendarRect.Top && v.Y < m_sCalendarRect.Bottom)
					return this;
				if (v.X >= 0 && v.X < getWidth() && v.Y >= 0 && v.Y < getHeight())
					return this;
				return nullptr;
			}
			return CControl::getControl(position);
		}

		RectF CDatePicker::getRenderRect()
		{
			RectF result{ AddShadow(getRect(), m_aShadowColor[0], m_aShadowShift[0], m_aShadowRadius[0]) };
			for (int i = 1; i <= (int)State::Disabled; i++)
				result += AddShadow(getRect(), m_aShadowColor[i], m_aShadowShift[i], m_aShadowRadius[i]);
			if (m_bOpened)
				result += AddShadow(m_sCalendarRect, m_sCalendarShadowColor, m_sCalendarShadowShift, m_iCalendarShadowRadius);
			return result;
		}

		bool CDatePicker::hasExtra()
		{
			return m_bOpened;
		}
	#pragma endregion

	#pragma region IControl setters
		bool CDatePicker::setDPI(const Point &value)
		{
			CLockRepaint lock{ this };
			Point old{ getDPI() };
			if (CControl::setDPI(value))
			{
				Close();
				PointF s{ (float)value.X / (float)old.X, (float)value.Y / (float)old.Y };
				float avg{ (s.X + s.Y) * 0.5f };
				for (int i = 0; i <= (int)State::Disabled; i++)
				{
					m_aShadowRadius[i] = ntl::Round<int>((float)m_aShadowRadius[i] * avg);
					m_aShadowShift[i] *= s;
					m_aBorderRadius[i] *= avg;
					m_aOuterBorderWidth[i] *= s;
					m_aInnerBorderWidth[i] *= s;
					m_aUpArrowBorderRadius[i] *= avg;
					m_aUpArrowOuterBorderWidth[i] *= s;
					m_aUpArrowInnerBorderWidth[i] *= s;
					m_aUpArrowPadding[i] *= s;
					m_aDownArrowBorderRadius[i] *= avg;
					m_aDownArrowOuterBorderWidth[i] *= s;
					m_aDownArrowInnerBorderWidth[i] *= s;
					m_aDownArrowPadding[i] *= s;
					m_aArrowBorderRadius[i] *= avg;
					m_aArrowOuterBorderWidth[i] *= s;
					m_aArrowInnerBorderWidth[i] *= s;
					m_aArrowPadding[i] *= s;
					m_aIconPadding[i] *= s;
					m_aElementPadding[i] *= s.X;
				}
				m_fCalendarMargin *= s.Y;
				m_sCalendarOuterBorderWidth *= s;
				m_sCalendarInnerBorderWidth *= s;
				m_sCalendarPadding *= s;
				m_iCalendarShadowRadius = ntl::Round<int>((float)m_iCalendarShadowRadius * avg);
				m_sCalendarShadowShift *= s;
				m_sCalendarBorderRadius *= avg;
				m_bFirstDigit = true;
				getMonthCalendar()->setDPI(value);
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}
	#pragma endregion

	#pragma region IControl methods
		void CDatePicker::Refresh(const bool refresh_children)
		{
			if (m_pCanvas)
				m_pCanvas->setValid(false);
			if (m_pCanvasCalendar)
				m_pCanvasCalendar->setValid(false);
		}
	#pragma endregion

	#pragma region IDatePicker getters
		int CDatePicker::getYear()
		{
			return getMonthCalendar()->getYear();
		}

		int CDatePicker::getMonth()
		{
			return getMonthCalendar()->getMonth();
		}

		int CDatePicker::getDay()
		{
			return getMonthCalendar()->getDay();
		}

		int CDatePicker::getMinYear()
		{
			return getMonthCalendar()->getMinYear();
		}

		int CDatePicker::getMinMonth()
		{
			return getMonthCalendar()->getMinMonth();
		}

		int CDatePicker::getMinDay()
		{
			return getMonthCalendar()->getMinDay();
		}

		int CDatePicker::getMaxYear()
		{
			return getMonthCalendar()->getMaxYear();
		}

		int CDatePicker::getMaxMonth()
		{
			return getMonthCalendar()->getMaxMonth();
		}

		int CDatePicker::getMaxDay()
		{
			return getMonthCalendar()->getMaxDay();
		}
	#pragma endregion

	#pragma region IDatePicker setters
		bool CDatePicker::setYear(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setYear(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setMonth(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setMonth(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setDay(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setDay(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setMinYear(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setMinYear(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setMinMonth(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setMinMonth(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setMinDay(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setMinDay(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setMaxYear(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setMaxYear(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setMaxMonth(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setMaxMonth(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setMaxDay(const int value)
		{
			CLockRepaint lock{ this };
			if (getMonthCalendar()->setMaxDay(value))
			{
				Close();
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}
	#pragma endregion

	#pragma region CBuiltInMonthCalendar getters
		CBuiltInMonthCalendar::Mode CDatePicker::getCalendarMode()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getMode();
			return CBuiltInMonthCalendar::Mode::Month;
		}

		bool CDatePicker::isCalendarShowToday()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->isShowToday();
			return false;
		}

		RectF CDatePicker::getCalendarTitlePadding()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePadding();
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTodayPadding()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayPadding();
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarElementPadding()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementPadding();
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarDayPadding()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayPadding();
			return RectF{ 0, 0, 0, 0 };
		}

		float CDatePicker::getCalendarTodayMargin()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayMargin();
			return 0;
		}

		float CDatePicker::getCalendarTodayRectWidth()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayRectWidth();
			return 0;
		}

		bool CDatePicker::isCalendarAnimate()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->isAnimate();
			return false;
		}

		float CDatePicker::getCalendarAnimateInterval()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getAnimateInterval();
			return 0;
		}

		float CDatePicker::getCalendarAnimateMinScale()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getAnimateMinScale();
			return 0;
		}

		float CDatePicker::getCalendarAnimateTime()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getAnimateTime();
			return 0;
		}

		float CDatePicker::getCalendarScrollInterval()
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getScrollInterval();
			return 0;
		}

		TextAlign CDatePicker::getCalendarTitleAlign(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleAlign(state);
			return TextAlign::Left;
		}

		RectF CDatePicker::getCalendarTitleBorderRadius(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleBorderRadius(state);
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTitleBorderWidth(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleBorderWidth(state);
			return RectF{ 0, 0, 0, 0 };
		}

		BorderColor CDatePicker::getCalendarTitleBorderColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleBorderColor(state);
			return BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } };
		}

		Color CDatePicker::getCalendarTitleBackgroundColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleBackgroundColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		Gradient *CDatePicker::getCalendarTitleBackgroundGradient(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleBackgroundGradient(state);
			return nullptr;
		}

		Color CDatePicker::getCalendarTitleColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTitlePrevRangeBorderRadius(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangeBorderRadius(state);
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTitlePrevRangeBorderWidth(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangeBorderWidth(state);
			return RectF{ 0, 0, 0, 0 };
		}

		BorderColor CDatePicker::getCalendarTitlePrevRangeBorderColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangeBorderColor(state);
			return BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } };
		}

		Color CDatePicker::getCalendarTitlePrevRangeBackgroundColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangeBackgroundColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		Gradient *CDatePicker::getCalendarTitlePrevRangeBackgroundGradient(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangeBackgroundGradient(state);
			return nullptr;
		}

		RectF CDatePicker::getCalendarTitlePrevRangePadding(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangePadding(state);
			return RectF{ 0, 0, 0, 0 };
		}

		Color CDatePicker::getCalendarTitlePrevRangeColor1(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangeColor1(state);
			return Color{ 0, 0, 0, 0 };
		}

		Color CDatePicker::getCalendarTitlePrevRangeColor2(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangeColor2(state);
			return Color{ 0, 0, 0, 0 };
		}

		Color CDatePicker::getCalendarTitlePrevRangeColor3(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitlePrevRangeColor3(state);
			return Color{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTitleNextRangeBorderRadius(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangeBorderRadius(state);
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTitleNextRangeBorderWidth(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangeBorderWidth(state);
			return RectF{ 0, 0, 0, 0 };
		}

		BorderColor CDatePicker::getCalendarTitleNextRangeBorderColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangeBorderColor(state);
			return BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } };
		}

		Color CDatePicker::getCalendarTitleNextRangeBackgroundColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangeBackgroundColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		Gradient *CDatePicker::getCalendarTitleNextRangeBackgroundGradient(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangeBackgroundGradient(state);
			return nullptr;
		}

		RectF CDatePicker::getCalendarTitleNextRangePadding(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangePadding(state);
			return RectF{ 0, 0, 0, 0 };
		}

		Color CDatePicker::getCalendarTitleNextRangeColor1(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangeColor1(state);
			return Color{ 0, 0, 0, 0 };
		}

		Color CDatePicker::getCalendarTitleNextRangeColor2(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangeColor2(state);
			return Color{ 0, 0, 0, 0 };
		}

		Color CDatePicker::getCalendarTitleNextRangeColor3(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTitleNextRangeColor3(state);
			return Color{ 0, 0, 0, 0 };
		}

		TextAlign CDatePicker::getCalendarTodayAlign(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayAlign(state);
			return TextAlign::Left;
		}

		RectF CDatePicker::getCalendarTodayBorderRadius(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayBorderRadius(state);
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTodayBorderWidth(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayBorderWidth(state);
			return RectF{ 0, 0, 0, 0 };
		}

		BorderColor CDatePicker::getCalendarTodayBorderColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayBorderColor(state);
			return BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } };
		}

		Color CDatePicker::getCalendarTodayBackgroundColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayBackgroundColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		Gradient *CDatePicker::getCalendarTodayBackgroundGradient(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayBackgroundGradient(state);
			return nullptr;
		}

		Color CDatePicker::getCalendarTodayColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTodayRectBorderRadius(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayRectBorderRadius(state);
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarTodayRectBorderWidth(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayRectBorderWidth(state);
			return RectF{ 0, 0, 0, 0 };
		}

		BorderColor CDatePicker::getCalendarTodayRectBorderColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayRectBorderColor(state);
			return BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } };
		}

		Color CDatePicker::getCalendarTodayRectBackgroundColor(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayRectBackgroundColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		Gradient *CDatePicker::getCalendarTodayRectBackgroundGradient(const CBuiltInMonthCalendar::TitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getTodayRectBackgroundGradient(state);
			return nullptr;
		}

		TextAlign CDatePicker::getCalendarElementHorizontalAlign(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementHorizontalAlign(state);
			return TextAlign::Left;
		}

		VerticalAlign CDatePicker::getCalendarElementVerticalAlign(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementVerticalAlign(state);
			return VerticalAlign::Top;
		}

		RectF CDatePicker::getCalendarElementBorderRadius(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementBorderRadius(state);
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarElementBorderWidth(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementBorderWidth(state);
			return RectF{ 0, 0, 0, 0 };
		}

		BorderColor CDatePicker::getCalendarElementBorderColor(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementBorderColor(state);
			return BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } };
		}

		Color CDatePicker::getCalendarElementBackgroundColor(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementBackgroundColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		Gradient *CDatePicker::getCalendarElementBackgroundGradient(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementBackgroundGradient(state);
			return nullptr;
		}

		Color CDatePicker::getCalendarElementColor(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		Color CDatePicker::getCalendarElementOutlineColor(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementOutlineColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		unsigned int CDatePicker::getCalendarElementOutlineMask(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getElementOutlineMask(state);
			return 0;
		}

		TextAlign CDatePicker::getCalendarDayHorizontalAlign(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayHorizontalAlign(state);
			return TextAlign::Left;
		}

		VerticalAlign CDatePicker::getCalendarDayVerticalAlign(const CBuiltInMonthCalendar::ElementState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayVerticalAlign(state);
			return VerticalAlign::Top;
		}

		TextAlign CDatePicker::getCalendarDayTitleHorizontalAlign(const CBuiltInMonthCalendar::DayTitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayTitleHorizontalAlign(state);
			return TextAlign::Left;
		}

		VerticalAlign CDatePicker::getCalendarDayTitleVerticalAlign(const CBuiltInMonthCalendar::DayTitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayTitleVerticalAlign(state);
			return VerticalAlign::Top;
		}

		RectF CDatePicker::getCalendarDayTitleBorderRadius(const CBuiltInMonthCalendar::DayTitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayTitleBorderRadius(state);
			return RectF{ 0, 0, 0, 0 };
		}

		RectF CDatePicker::getCalendarDayTitleBorderWidth(const CBuiltInMonthCalendar::DayTitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayTitleBorderWidth(state);
			return RectF{ 0, 0, 0, 0 };
		}

		BorderColor CDatePicker::getCalendarDayTitleBorderColor(const CBuiltInMonthCalendar::DayTitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayTitleBorderColor(state);
			return BorderColor{ Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 }, Color{ 0, 0, 0, 0 } };
		}

		Color CDatePicker::getCalendarDayTitleBackgroundColor(const CBuiltInMonthCalendar::DayTitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayTitleBackgroundColor(state);
			return Color{ 0, 0, 0, 0 };
		}

		Gradient *CDatePicker::getCalendarDayTitleBackgroundGradient(const CBuiltInMonthCalendar::DayTitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayTitleBackgroundGradient(state);
			return nullptr;
		}

		Color CDatePicker::getCalendarDayTitleColor(const CBuiltInMonthCalendar::DayTitleState state)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b)
				return b->getDayTitleColor(state);
			return Color{ 0, 0, 0, 0 };
		}
	#pragma endregion

	#pragma region CBuiltInMonthCalendar setters
		bool CDatePicker::setCalendarMode(const CBuiltInMonthCalendar::Mode value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setMode(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarShowToday(const bool value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setShowToday(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePadding(const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePadding(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayPadding(const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayPadding(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementPadding(const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementPadding(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayPadding(const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayPadding(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayMargin(const float value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayMargin(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayRectWidth(const float value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayRectWidth(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarAnimate(const bool value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setAnimate(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarAnimateInterval(const float value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setAnimateInterval(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarAnimateMinScale(const float value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setAnimateMinScale(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarAnimateTime(const float value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setAnimateTime(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarScrollInterval(const float value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setScrollInterval(value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleAlign(const CBuiltInMonthCalendar::TitleState state, const TextAlign value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleAlign(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleBorderRadius(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleBorderRadius(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleBorderWidth(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleBorderWidth(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleBorderColor(const CBuiltInMonthCalendar::TitleState state, const BorderColor &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleBorderColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleBackgroundColor(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleBackgroundColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleColor(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePrevRangeBorderRadius(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePrevRangeBorderRadius(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePrevRangeBorderWidth(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePrevRangeBorderWidth(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePrevRangeBorderColor(const CBuiltInMonthCalendar::TitleState state, const BorderColor &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePrevRangeBorderColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePrevRangeBackgroundColor(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePrevRangeBackgroundColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePrevRangePadding(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePrevRangePadding(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePrevRangeColor1(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePrevRangeColor1(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePrevRangeColor2(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePrevRangeColor2(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitlePrevRangeColor3(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitlePrevRangeColor3(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleNextRangeBorderRadius(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleNextRangeBorderRadius(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleNextRangeBorderWidth(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleNextRangeBorderWidth(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleNextRangeBorderColor(const CBuiltInMonthCalendar::TitleState state, const BorderColor &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleNextRangeBorderColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleNextRangeBackgroundColor(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleNextRangeBackgroundColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleNextRangePadding(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleNextRangePadding(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleNextRangeColor1(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleNextRangeColor1(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleNextRangeColor2(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleNextRangeColor2(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTitleNextRangeColor3(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTitleNextRangeColor3(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayAlign(const CBuiltInMonthCalendar::TitleState state, const TextAlign value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayAlign(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayBorderRadius(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayBorderRadius(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayBorderWidth(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayBorderWidth(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayBorderColor(const CBuiltInMonthCalendar::TitleState state, const BorderColor &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayBorderColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayBackgroundColor(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayBackgroundColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayColor(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayRectBorderRadius(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayRectBorderRadius(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayRectBorderWidth(const CBuiltInMonthCalendar::TitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayRectBorderWidth(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayRectBorderColor(const CBuiltInMonthCalendar::TitleState state, const BorderColor &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayRectBorderColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarTodayRectBackgroundColor(const CBuiltInMonthCalendar::TitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setTodayRectBackgroundColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementHorizontalAlign(const CBuiltInMonthCalendar::ElementState state, const TextAlign value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementHorizontalAlign(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementVerticalAlign(const CBuiltInMonthCalendar::ElementState state, const VerticalAlign value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementVerticalAlign(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementBorderRadius(const CBuiltInMonthCalendar::ElementState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementBorderRadius(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementBorderWidth(const CBuiltInMonthCalendar::ElementState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementBorderWidth(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementBorderColor(const CBuiltInMonthCalendar::ElementState state, const BorderColor &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementBorderColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementBackgroundColor(const CBuiltInMonthCalendar::ElementState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementBackgroundColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementColor(const CBuiltInMonthCalendar::ElementState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementOutlineColor(const CBuiltInMonthCalendar::ElementState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementOutlineColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarElementOutlineMask(const CBuiltInMonthCalendar::ElementState state, const unsigned int value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setElementOutlineMask(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayHorizontalAlign(const CBuiltInMonthCalendar::ElementState state, const TextAlign value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayHorizontalAlign(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayVerticalAlign(const CBuiltInMonthCalendar::ElementState state, const VerticalAlign value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayVerticalAlign(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayTitleHorizontalAlign(const CBuiltInMonthCalendar::DayTitleState state, const TextAlign value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayTitleHorizontalAlign(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayTitleVerticalAlign(const CBuiltInMonthCalendar::DayTitleState state, const VerticalAlign value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayTitleVerticalAlign(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayTitleBorderRadius(const CBuiltInMonthCalendar::DayTitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayTitleBorderRadius(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayTitleBorderWidth(const CBuiltInMonthCalendar::DayTitleState state, const RectF &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayTitleBorderWidth(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayTitleBorderColor(const CBuiltInMonthCalendar::DayTitleState state, const BorderColor &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayTitleBorderColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayTitleBackgroundColor(const CBuiltInMonthCalendar::DayTitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayTitleBackgroundColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarDayTitleColor(const CBuiltInMonthCalendar::DayTitleState state, const Color &value)
		{
			CBuiltInMonthCalendar *b{ cast<CBuiltInMonthCalendar*>(getMonthCalendar()) };
			if (b && b->setDayTitleColor(state, value))
			{
				Close();
				return true;
			}
			return false;
		}
	#pragma endregion

	#pragma region Getters
		CDatePicker::State CDatePicker::getState()
		{
			if (!isEnabled(false))
				return State::Disabled;
			if (m_eDownElement != Element::None || m_bOpened)
			{
				if (isHovered())
					return State::ActiveHovered;
				return State::Active;
			}
			if (isFocused())
			{
				if (isHovered())
					return State::FocusedHovered;
				return State::Focused;
			}
			if (isHovered())
				return State::Hovered;
			return State::Normal;
		}

		CDatePicker::DisplayMode CDatePicker::getDisplayMode() const
		{
			return m_eDisplayMode;
		}

		CDatePicker::MonthFormat CDatePicker::getMonthFormat() const
		{
			return m_eMonthFormat;
		}

		CDatePicker::ElementOrder CDatePicker::getElementOrder() const
		{
			return m_eElementOrder;
		}

		CDatePicker::OpenDirection CDatePicker::getOpenDirection() const
		{
			return m_eOpenDirection;
		}

		CDatePicker::OpenAlign CDatePicker::getOpenAlign() const
		{
			return m_eOpenAlign;
		}

		String CDatePicker::getSeparator1() const
		{
			return m_sSeparator1;
		}

		String CDatePicker::getSeparator2() const
		{
			return m_sSeparator2;
		}

		bool CDatePicker::isShowDayLeadingZeros() const
		{
			return m_bShowDayLeadingZeros;
		}

		bool CDatePicker::isShowMonthLeadingZeros() const
		{
			return m_bShowMonthLeadingZeros;
		}

		bool CDatePicker::isShowYearLeadingZeros() const
		{
			return m_bShowYearLeadingZeros;
		}

		bool CDatePicker::isShowIcon() const
		{
			return m_bShowIcon;
		}

		float CDatePicker::getTimerInterval() const
		{
			return m_fTimerInterval;
		}

		bool CDatePicker::isArrowsAtRight() const
		{
			return m_bArrowsAtRight;
		}

		TextAlign CDatePicker::getContentAlign() const
		{
			return m_eContentAlign;
		}

		int CDatePicker::getShadowRadius(const State state) const
		{
			return m_aShadowRadius[(int)state];
		}

		PointF CDatePicker::getShadowShift(const State state) const
		{
			return m_aShadowShift[(int)state];
		}

		Color CDatePicker::getShadowColor(const State state) const
		{
			return m_aShadowColor[(int)state];
		}

		RectF CDatePicker::getBorderRadius(const State state) const
		{
			return m_aBorderRadius[(int)state];
		}

		RectF CDatePicker::getOuterBorderWidth(const State state) const
		{
			return m_aOuterBorderWidth[(int)state];
		}

		BorderColor CDatePicker::getOuterBorderColor(const State state) const
		{
			return m_aOuterBorderColor[(int)state];
		}

		RectF CDatePicker::getInnerBorderWidth(const State state) const
		{
			return m_aInnerBorderWidth[(int)state];
		}

		BorderColor CDatePicker::getInnerBorderColor(const State state) const
		{
			return m_aInnerBorderColor[(int)state];
		}

		Color CDatePicker::getBackgroundColor(const State state) const
		{
			return m_aBackgroundColor[(int)state];
		}

		Gradient *CDatePicker::getBackgroundGradient(const State state)
		{
			return &m_aBackgroundGradient[(int)state];
		}

		RectF CDatePicker::getUpArrowBorderRadius(const State state) const
		{
			return m_aUpArrowBorderRadius[(int)state];
		}

		RectF CDatePicker::getUpArrowOuterBorderWidth(const State state) const
		{
			return m_aUpArrowOuterBorderWidth[(int)state];
		}

		RectF CDatePicker::getUpArrowInnerBorderWidth(const State state) const
		{
			return m_aUpArrowInnerBorderWidth[(int)state];
		}

		BorderColor CDatePicker::getUpArrowOuterBorderColor(const State state) const
		{
			return m_aUpArrowOuterBorderColor[(int)state];
		}

		BorderColor CDatePicker::getUpArrowInnerBorderColor(const State state) const
		{
			return m_aUpArrowInnerBorderColor[(int)state];
		}

		Color CDatePicker::getUpArrowBackgroundColor(const State state) const
		{
			return m_aUpArrowBackgroundColor[(int)state];
		}

		Gradient *CDatePicker::getUpArrowBackgroundGradient(const State state)
		{
			return &m_aUpArrowBackgroundGradient[(int)state];
		}

		RectF CDatePicker::getUpArrowPadding(const State state) const
		{
			return m_aUpArrowPadding[(int)state];
		}

		Color CDatePicker::getUpArrowColor1(const State state) const
		{
			return m_aUpArrowColor1[(int)state];
		}

		Color CDatePicker::getUpArrowColor2(const State state) const
		{
			return m_aUpArrowColor2[(int)state];
		}

		Color CDatePicker::getUpArrowColor3(const State state) const
		{
			return m_aUpArrowColor3[(int)state];
		}

		RectF CDatePicker::getDownArrowBorderRadius(const State state) const
		{
			return m_aDownArrowBorderRadius[(int)state];
		}

		RectF CDatePicker::getDownArrowOuterBorderWidth(const State state) const
		{
			return m_aDownArrowOuterBorderWidth[(int)state];
		}

		RectF CDatePicker::getDownArrowInnerBorderWidth(const State state) const
		{
			return m_aDownArrowInnerBorderWidth[(int)state];
		}

		BorderColor CDatePicker::getDownArrowOuterBorderColor(const State state) const
		{
			return m_aDownArrowOuterBorderColor[(int)state];
		}

		BorderColor CDatePicker::getDownArrowInnerBorderColor(const State state) const
		{
			return m_aDownArrowInnerBorderColor[(int)state];
		}

		Color CDatePicker::getDownArrowBackgroundColor(const State state) const
		{
			return m_aDownArrowBackgroundColor[(int)state];
		}

		Gradient *CDatePicker::getDownArrowBackgroundGradient(const State state)
		{
			return &m_aDownArrowBackgroundGradient[(int)state];
		}

		RectF CDatePicker::getDownArrowPadding(const State state) const
		{
			return m_aDownArrowPadding[(int)state];
		}

		Color CDatePicker::getDownArrowColor1(const State state) const
		{
			return m_aDownArrowColor1[(int)state];
		}

		Color CDatePicker::getDownArrowColor2(const State state) const
		{
			return m_aDownArrowColor2[(int)state];
		}

		Color CDatePicker::getDownArrowColor3(const State state) const
		{
			return m_aDownArrowColor3[(int)state];
		}

		float CDatePicker::getArrowDistance(const State state) const
		{
			return m_aArrowDistance[(int)state];
		}

		RectF CDatePicker::getArrowBorderRadius(const State state) const
		{
			return m_aArrowBorderRadius[(int)state];
		}

		RectF CDatePicker::getArrowOuterBorderWidth(const State state) const
		{
			return m_aArrowOuterBorderWidth[(int)state];
		}

		RectF CDatePicker::getArrowInnerBorderWidth(const State state) const
		{
			return m_aArrowInnerBorderWidth[(int)state];
		}

		BorderColor CDatePicker::getArrowOuterBorderColor(const State state) const
		{
			return m_aArrowOuterBorderColor[(int)state];
		}

		BorderColor CDatePicker::getArrowInnerBorderColor(const State state) const
		{
			return m_aArrowInnerBorderColor[(int)state];
		}

		Color CDatePicker::getArrowBackgroundColor(const State state) const
		{
			return m_aArrowBackgroundColor[(int)state];
		}

		Gradient *CDatePicker::getArrowBackgroundGradient(const State state)
		{
			return &m_aArrowBackgroundGradient[(int)state];
		}

		RectF CDatePicker::getArrowPadding(const State state) const
		{
			return m_aArrowPadding[(int)state];
		}

		Color CDatePicker::getArrowColor1(const State state) const
		{
			return m_aArrowColor1[(int)state];
		}

		Color CDatePicker::getArrowColor2(const State state) const
		{
			return m_aArrowColor2[(int)state];
		}

		Color CDatePicker::getArrowColor3(const State state) const
		{
			return m_aArrowColor3[(int)state];
		}

		IImageList *CDatePicker::getImageList()
		{
			return m_pImageList;
		}

		int CDatePicker::getIconIndex(const State state) const
		{
			return m_aIconIndex[(int)state];
		}

		RectF CDatePicker::getIconPadding(const State state) const
		{
			return m_aIconPadding[(int)state];
		}

		Color CDatePicker::getElementBackgroundColor(const State state) const
		{
			return m_aElementBackgroundColor[(int)state];
		}

		Gradient *CDatePicker::getElementBackgroundGradient(const State state)
		{
			return &m_aElementBackgroundGradient[(int)state];
		}

		Color CDatePicker::getElementColor(const State state) const
		{
			return m_aElementColor[(int)state];
		}

		float CDatePicker::getElementPadding(const State state) const
		{
			return m_aElementPadding[(int)state];
		}

		float CDatePicker::getCalendarMargin() const
		{
			return m_fCalendarMargin;
		}

		RectF CDatePicker::getCalendarOuterBorderWidth() const
		{
			return m_sCalendarOuterBorderWidth;
		}

		RectF CDatePicker::getCalendarInnerBorderWidth() const
		{
			return m_sCalendarInnerBorderWidth;
		}

		RectF CDatePicker::getCalendarPadding() const
		{
			return m_sCalendarPadding;
		}

		int CDatePicker::getCalendarShadowRadius() const
		{
			return m_iCalendarShadowRadius;
		}

		PointF CDatePicker::getCalendarShadowShift() const
		{
			return m_sCalendarShadowShift;
		}

		Color CDatePicker::getCalendarShadowColor() const
		{
			return m_sCalendarShadowColor;
		}

		RectF CDatePicker::getCalendarBorderRadius() const
		{
			return m_sCalendarBorderRadius;
		}

		BorderColor CDatePicker::getCalendarOuterBorderColor() const
		{
			return m_sCalendarOuterBorderColor;
		}

		BorderColor CDatePicker::getCalendarInnerBorderColor() const
		{
			return m_sCalendarInnerBorderColor;
		}

		Color CDatePicker::getCalendarBackgroundColor() const
		{
			return m_sCalendarBackgroundColor;
		}

		Gradient *CDatePicker::getCalendarBackgroundGradient()
		{
			return &m_cCalendarBackgroundGradient;
		}
	#pragma endregion

	#pragma region Setters
		bool CDatePicker::setMonthCalendar(IBuiltInMonthCalendar *value)
		{
			if (value && value != m_pMonthCalendar)
			{
				Close();
				if (m_pMonthCalendar)
					m_pMonthCalendar->Release();
				m_pMonthCalendar = value;
				m_pMonthCalendar->setListener(&m_cListener);
				return true;
			}
			return false;
		}

		bool CDatePicker::setDisplayMode(const DisplayMode value)
		{
			if (value != m_eDisplayMode)
			{
				CLockRepaint lock{ this };
				Close();
				m_eDisplayMode = value;
				m_bFirstDigit = true;
				UpdateHoveredElement();
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setMonthFormat(const MonthFormat value)
		{
			if (value != m_eMonthFormat)
			{
				m_eMonthFormat = value;
				m_bFirstDigit = true;
				UpdateHoveredElement();
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setElementOrder(const ElementOrder value)
		{
			if (value != m_eElementOrder)
			{
				m_eElementOrder = value;
				m_bFirstDigit = true;
				UpdateHoveredElement();
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setOpenDirection(const OpenDirection value)
		{
			if (value != m_eOpenDirection)
			{
				CLockRepaint lock{ this };
				Close();
				m_eOpenDirection = value;
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setOpenAlign(const OpenAlign value)
		{
			if (value != m_eOpenAlign)
			{
				CLockRepaint lock{ this };
				Close();
				m_eOpenAlign = value;
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setSeparator1(const String &value)
		{
			if (value != m_sSeparator1)
			{
				m_sSeparator1 = value;
				m_bFirstDigit = true;
				UpdateHoveredElement();
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setSeparator2(const String &value)
		{
			if (value != m_sSeparator2)
			{
				m_sSeparator2 = value;
				m_bFirstDigit = true;
				UpdateHoveredElement();
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setShowDayLeadingZeros(const bool value)
		{
			if (value != m_bShowDayLeadingZeros)
			{
				m_bShowDayLeadingZeros = value;
				m_bFirstDigit = true;
				UpdateHoveredElement();
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setShowMonthLeadingZeros(const bool value)
		{
			if (value != m_bShowMonthLeadingZeros)
			{
				m_bShowMonthLeadingZeros = value;
				m_bFirstDigit = true;
				if (m_eMonthFormat == MonthFormat::Short)
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setShowYearLeadingZeros(const bool value)
		{
			if (value != m_bShowYearLeadingZeros)
			{
				m_bShowYearLeadingZeros = value;
				m_bFirstDigit = true;
				UpdateHoveredElement();
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setShowIcon(const bool value)
		{
			if (value != m_bShowIcon)
			{
				m_bShowIcon = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown)
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setTimerInterval(const float value)
		{
			if (ntl::IsGreater<float>(value, 0) && ntl::IsNotEqual<float>(value, m_fTimerInterval))
			{
				m_fTimerInterval = value;
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowsAtRight(const bool value)
		{
			if (value != m_bArrowsAtRight)
			{
				m_bArrowsAtRight = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown)
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setContentAlign(const TextAlign value)
		{
			if (value != m_eContentAlign)
			{
				m_eContentAlign = value;
				m_bFirstDigit = true;
				UpdateHoveredElement();
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::setShadowRadius(const State state, const int value)
		{
			if (value > 0 && value != m_aShadowRadius[(int)state])
			{
				CLockRepaint lock{ this };
				State s{ getState() };
				if (s == state && m_aShadowColor[(int)state].A > 0)
					Repaint(false);
				m_aShadowRadius[(int)state] = value;
				m_bFirstDigit = true;
				if (s == state && m_aShadowColor[(int)state].A > 0)
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setShadowShift(const State state, const PointF &value)
		{
			if (IsNotEqual(value, m_aShadowShift[(int)state]))
			{
				CLockRepaint lock{ this };
				State s{ getState() };
				if (s == state && m_aShadowColor[(int)state].A > 0)
					Repaint(false);
				m_aShadowShift[(int)state] = value;
				m_bFirstDigit = true;
				if (s == state && m_aShadowColor[(int)state].A > 0)
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setShadowColor(const State state, const Color &value)
		{
			if (value != m_aShadowColor[(int)state])
			{
				CLockRepaint lock{ this };
				State s{ getState() };
				if (s == state)
					Repaint(false);
				m_aShadowColor[(int)state] = value;
				m_bFirstDigit = true;
				if (s == state)
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setBorderRadius(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aBorderRadius[(int)state]))
			{
				m_aBorderRadius[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setOuterBorderWidth(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aOuterBorderWidth[(int)state]))
			{
				m_aOuterBorderWidth[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setOuterBorderColor(const State state, const BorderColor &value)
		{
			if (value != m_aOuterBorderColor[(int)state])
			{
				m_aOuterBorderColor[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setInnerBorderWidth(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aInnerBorderWidth[(int)state]))
			{
				m_aInnerBorderWidth[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setInnerBorderColor(const State state, const BorderColor &value)
		{
			if (value != m_aInnerBorderColor[(int)state])
			{
				m_aInnerBorderColor[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setBackgroundColor(const State state, const Color &value)
		{
			if (value != m_aBackgroundColor[(int)state])
			{
				m_aBackgroundColor[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowBorderRadius(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aUpArrowBorderRadius[(int)state]))
			{
				m_aUpArrowBorderRadius[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowOuterBorderWidth(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aUpArrowOuterBorderWidth[(int)state]))
			{
				m_aUpArrowOuterBorderWidth[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowInnerBorderWidth(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aUpArrowInnerBorderWidth[(int)state]))
			{
				m_aUpArrowInnerBorderWidth[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowOuterBorderColor(const State state, const BorderColor &value)
		{
			if (value != m_aUpArrowOuterBorderColor[(int)state])
			{
				m_aUpArrowOuterBorderColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && m_aUpArrowOuterBorderWidth[(int)state].has_positive() && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowInnerBorderColor(const State state, const BorderColor &value)
		{
			if (value != m_aUpArrowInnerBorderColor[(int)state])
			{
				m_aUpArrowInnerBorderColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && m_aUpArrowInnerBorderWidth[(int)state].has_positive() && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowBackgroundColor(const State state, const Color &value)
		{
			if (value != m_aUpArrowBackgroundColor[(int)state])
			{
				m_aUpArrowBackgroundColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowPadding(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aUpArrowPadding[(int)state]))
			{
				m_aUpArrowPadding[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowColor1(const State state, const Color &value)
		{
			if (value != m_aUpArrowColor1[(int)state])
			{
				m_aUpArrowColor1[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowColor2(const State state, const Color &value)
		{
			if (value != m_aUpArrowColor2[(int)state])
			{
				m_aUpArrowColor2[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setUpArrowColor3(const State state, const Color &value)
		{
			if (value != m_aUpArrowColor3[(int)state])
			{
				m_aUpArrowColor3[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowBorderRadius(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aDownArrowBorderRadius[(int)state]))
			{
				m_aDownArrowBorderRadius[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowOuterBorderWidth(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aDownArrowOuterBorderWidth[(int)state]))
			{
				m_aDownArrowOuterBorderWidth[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowInnerBorderWidth(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aDownArrowInnerBorderWidth[(int)state]))
			{
				m_aDownArrowInnerBorderWidth[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowOuterBorderColor(const State state, const BorderColor &value)
		{
			if (value != m_aDownArrowOuterBorderColor[(int)state])
			{
				m_aDownArrowOuterBorderColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && m_aDownArrowOuterBorderWidth[(int)state].has_positive() && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowInnerBorderColor(const State state, const BorderColor &value)
		{
			if (value != m_aDownArrowInnerBorderColor[(int)state])
			{
				m_aDownArrowInnerBorderColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && m_aDownArrowInnerBorderWidth[(int)state].has_positive() && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowBackgroundColor(const State state, const Color &value)
		{
			if (value != m_aDownArrowBackgroundColor[(int)state])
			{
				m_aDownArrowBackgroundColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowPadding(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aDownArrowPadding[(int)state]))
			{
				m_aDownArrowPadding[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowColor1(const State state, const Color &value)
		{
			if (value != m_aDownArrowColor1[(int)state])
			{
				m_aDownArrowColor1[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowColor2(const State state, const Color &value)
		{
			if (value != m_aDownArrowColor2[(int)state])
			{
				m_aDownArrowColor2[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setDownArrowColor3(const State state, const Color &value)
		{
			if (value != m_aDownArrowColor3[(int)state])
			{
				m_aDownArrowColor3[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::UpDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowDistance(const State state, const float value)
		{
			if (ntl::IsGreaterOrEqual<float>(value, 0) && ntl::IsNotEqual<float>(value, m_aArrowDistance[(int)state]))
			{
				m_aArrowDistance[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowBorderRadius(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aArrowBorderRadius[(int)state]))
			{
				m_aArrowBorderRadius[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowOuterBorderWidth(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aArrowOuterBorderWidth[(int)state]))
			{
				m_aArrowOuterBorderWidth[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowInnerBorderWidth(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aArrowInnerBorderWidth[(int)state]))
			{
				m_aArrowInnerBorderWidth[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowOuterBorderColor(const State state, const BorderColor &value)
		{
			if (value != m_aArrowOuterBorderColor[(int)state])
			{
				m_aArrowOuterBorderColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && m_aArrowOuterBorderWidth[(int)state].has_positive() && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowInnerBorderColor(const State state, const BorderColor &value)
		{
			if (value != m_aArrowInnerBorderColor[(int)state])
			{
				m_aArrowInnerBorderColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && m_aArrowInnerBorderWidth[(int)state].has_positive() && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowBackgroundColor(const State state, const Color &value)
		{
			if (value != m_aArrowBackgroundColor[(int)state])
			{
				m_aArrowBackgroundColor[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowPadding(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aArrowPadding[(int)state]))
			{
				m_aArrowPadding[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowColor1(const State state, const Color &value)
		{
			if (value != m_aArrowColor1[(int)state])
			{
				m_aArrowColor1[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowColor2(const State state, const Color &value)
		{
			if (value != m_aArrowColor2[(int)state])
			{
				m_aArrowColor2[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setArrowColor3(const State state, const Color &value)
		{
			if (value != m_aArrowColor3[(int)state])
			{
				m_aArrowColor3[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setImageList(IImageList *value)
		{
			if (value != m_pImageList)
			{
				m_pImageList = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown)
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setIconIndex(const State state, const int value)
		{
			int v{ ntl::Max<int>(-1, value) };
			if (v != m_aIconIndex[(int)state])
			{
				m_aIconIndex[(int)state] = value;
				m_bFirstDigit = true;
				if (m_pImageList && m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setIconPadding(const State state, const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_aIconPadding[(int)state]))
			{
				m_aIconPadding[(int)state] = value;
				m_bFirstDigit = true;
				if (m_eDisplayMode == DisplayMode::DropDown && state == getState())
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setElementBackgroundColor(const State state, const Color &value)
		{
			if (value != m_aElementBackgroundColor[(int)state])
			{
				m_aElementBackgroundColor[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setElementColor(const State state, const Color &value)
		{
			if (value != m_aElementColor[(int)state])
			{
				m_aElementColor[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setElementPadding(const State state, const float value)
		{
			if (ntl::IsGreaterOrEqual<float>(value, 0) && ntl::IsNotEqual<float>(value, m_aElementPadding[(int)state]))
			{
				m_aElementPadding[(int)state] = value;
				m_bFirstDigit = true;
				if (state == getState())
				{
					UpdateHoveredElement();
					if (m_pCanvas)
						m_pCanvas->setValid(false);
					Repaint(false);
				}
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarMargin(const float value)
		{
			if (ntl::IsGreaterOrEqual<float>(value, 0) && ntl::IsNotEqual<float>(value, m_fCalendarMargin))
			{
				Close();
				m_fCalendarMargin = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarOuterBorderWidth(const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_sCalendarOuterBorderWidth))
			{
				Close();
				m_sCalendarOuterBorderWidth = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarInnerBorderWidth(const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_sCalendarInnerBorderWidth))
			{
				Close();
				m_sCalendarInnerBorderWidth = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarPadding(const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_sCalendarPadding))
			{
				Close();
				m_sCalendarPadding = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarShadowRadius(const int value)
		{
			if (value > 0 && value != m_iCalendarShadowRadius)
			{
				Close();
				m_iCalendarShadowRadius = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarShadowShift(const PointF &value)
		{
			if (IsNotEqual(value, m_sCalendarShadowShift))
			{
				Close();
				m_sCalendarShadowShift = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarShadowColor(const Color &value)
		{
			if (value != m_sCalendarShadowColor)
			{
				Close();
				m_sCalendarShadowColor = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarBorderRadius(const RectF &value)
		{
			if (!value.has_negative() && IsNotEqual(value, m_sCalendarBorderRadius))
			{
				Close();
				m_sCalendarBorderRadius = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarOuterBorderColor(const BorderColor &value)
		{
			if (value != m_sCalendarOuterBorderColor)
			{
				Close();
				m_sCalendarOuterBorderColor = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarInnerBorderColor(const BorderColor &value)
		{
			if (value != m_sCalendarInnerBorderColor)
			{
				Close();
				m_sCalendarInnerBorderColor = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}

		bool CDatePicker::setCalendarBackgroundColor(const Color &value)
		{
			if (value != m_sCalendarBackgroundColor)
			{
				Close();
				m_sCalendarBackgroundColor = value;
				m_bFirstDigit = true;
				return true;
			}
			return false;
		}
	#pragma endregion

	#pragma region Methods
		bool CDatePicker::ActivateYears()
		{
			if (m_eActiveElement != Element::Years)
			{
				m_eActiveElement = Element::Years;
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::ActivateMonth()
		{
			if (m_eActiveElement != Element::Months)
			{
				m_eActiveElement = Element::Months;
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::ActivateDays()
		{
			if (m_eActiveElement != Element::Days)
			{
				m_eActiveElement = Element::Days;
				m_bFirstDigit = true;
				if (m_pCanvas)
					m_pCanvas->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::Open()
		{
			if (!m_bOpened && m_eDisplayMode == DisplayMode::DropDown && m_eDownElement == Element::None && getForm() && getForm()->getRenderer() && isEnabled(true))
			{
				m_bOpened = true;
				m_bFirstDigit = true;
				PointF size{ getMonthCalendar()->getRequiredSize() };
				PointF disp{ m_sCalendarOuterBorderWidth.Left + m_sCalendarInnerBorderWidth.Left + m_sCalendarPadding.Left,
					m_sCalendarOuterBorderWidth.Top + m_sCalendarInnerBorderWidth.Top + m_sCalendarPadding.Top };
				float w{ disp.X + size.X + m_sCalendarOuterBorderWidth.Right + m_sCalendarInnerBorderWidth.Right + m_sCalendarPadding.Right };
				float h{ disp.Y + size.Y + m_sCalendarOuterBorderWidth.Bottom + m_sCalendarInnerBorderWidth.Bottom + m_sCalendarPadding.Bottom };
				switch (m_eOpenAlign)
				{
				case OpenAlign::Right:
					m_sCalendarRect.Left = getWidth() - w;
					break;
				case OpenAlign::Center:
					m_sCalendarRect.Left = (getWidth() - w) * 0.5f;
					break;
				case OpenAlign::Justify:
					if (w < getWidth())
					{
						disp.X += (getWidth() - w) * 0.5f;
						disp.Y += (getWidth() - w) * 0.5f;
						h += getWidth() - w;
						w = ntl::Max<float>(w, getWidth());
					}
					m_sCalendarRect.Left = (getWidth() - w) * 0.5f;
					break;
				default:
					m_sCalendarRect.Left = 0;
				}
				m_sCalendarRect.Right = m_sCalendarRect.Left + w;
				switch (m_eOpenDirection)
				{
				case OpenDirection::Up:
					m_sCalendarRect.Top = -h - m_fCalendarMargin;
					break;
				case OpenDirection::Down:
					m_sCalendarRect.Top = getHeight() + m_fCalendarMargin;
					break;
				default:
					if (LocalToForm(PointF{ 0, getHeight() + m_fCalendarMargin }).Y < (float)getForm()->getClientHeight())
						m_sCalendarRect.Top = getHeight() + m_fCalendarMargin;
					else
						m_sCalendarRect.Top = -h - m_fCalendarMargin;
				}
				if (m_sCalendarRect.Left < 0 && LocalToForm(PointF{ m_sCalendarRect.Left, m_sCalendarRect.Top }).X < 0)
				{
					m_sCalendarRect.Left = 0;
					m_sCalendarRect.Right = m_sCalendarRect.Left + w;
				}
				m_sCalendarRect.Bottom = m_sCalendarRect.Top + h;
				m_eDownElement = Element::None;
				getMonthCalendar()->setSize(size);
				getMonthCalendar()->setPosition(disp);
				getForm()->CaptureMouse(this, true);
				if (m_pCanvasCalendar)
					m_pCanvasCalendar->setValid(false);
				Repaint(false);
				return true;
			}
			return false;
		}

		bool CDatePicker::Close()
		{
			if (m_bOpened)
			{
				CLockRepaint lock{ this };
				Repaint(false);
				m_bOpened = false;
				m_bFirstDigit = true;
				getMonthCalendar()->NotifyOnFreeResources();
				if (m_pCanvasCalendar)
				{
					m_pCanvasCalendar->Release();
					m_pCanvasCalendar = nullptr;
				}
				if (isCaptureMouse())
					getForm()->ReleaseCaptureMouse();
				return true;
			}
			return false;
		}
	#pragma endregion

	#pragma region Helpers
		void CDatePicker::UpdateFromStyle(IStyle *style)
		{
			Close();
			m_bIgnoreGradient = true;
			style->getOption(m_sClassName + L".ShowIcon", m_bShowIcon);
			style->getOption(m_sClassName + L".ArrowsAtRight", m_bArrowsAtRight);
			style->getOption(m_sClassName + L".CalendarMargin", m_fCalendarMargin);
			style->getOption(m_sClassName + L".CalendarOuterBorderWidth", m_sCalendarOuterBorderWidth);
			style->getOption(m_sClassName + L".CalendarInnerBorderWidth", m_sCalendarInnerBorderWidth);
			style->getOption(m_sClassName + L".CalendarPadding", m_sCalendarPadding);
			style->getOption(m_sClassName + L".CalendarShadowRadius", m_iCalendarShadowRadius);
			style->getOption(m_sClassName + L".CalendarShadowShift", m_sCalendarShadowShift);
			style->getOption(m_sClassName + L".CalendarShadowColor", m_sCalendarShadowColor);
			style->getOption(m_sClassName + L".CalendarBorderRadius", m_sCalendarBorderRadius);
			style->getOption(m_sClassName + L".CalendarOuterBorderColor", m_sCalendarOuterBorderColor);
			style->getOption(m_sClassName + L".CalendarInnerBorderColor", m_sCalendarInnerBorderColor);
			style->getOption(m_sClassName + L".CalendarBackgroundColor", m_sCalendarBackgroundColor);
			style->getOption(m_sClassName + L".CalendarBackgroundGradient", m_cCalendarBackgroundGradient);
			for (int i = 0; i <= (int)State::Disabled; i++)
			{
				String state;
				switch ((State)i)
				{
				case State::Hovered:
					state = L"Hovered";
					break;
				case State::Focused:
					state = L"Focused";
					break;
				case State::FocusedHovered:
					state = L"FocusedHovered";
					break;
				case State::Active:
					state = L"Active";
					break;
				case State::ActiveHovered:
					state = L"ActiveHovered";
					break;
				case State::Disabled:
					state = L"Disabled";
					break;
				default:
					state = L"Normal";
				}

				style->getOption(m_sClassName + L".ShadowRadius[" + state + L"]", m_aShadowRadius[i]);
				style->getOption(m_sClassName + L".ShadowShift[" + state + L"]", m_aShadowShift[i]);
				style->getOption(m_sClassName + L".ShadowColor[" + state + L"]", m_aShadowColor[i]);
				style->getOption(m_sClassName + L".BorderRadius[" + state + L"]", m_aBorderRadius[i]);
				style->getOption(m_sClassName + L".OuterBorderWidth[" + state + L"]", m_aOuterBorderWidth[i]);
				style->getOption(m_sClassName + L".OuterBorderColor[" + state + L"]", m_aOuterBorderColor[i]);
				style->getOption(m_sClassName + L".InnerBorderWidth[" + state + L"]", m_aInnerBorderWidth[i]);
				style->getOption(m_sClassName + L".InnerBorderColor[" + state + L"]", m_aInnerBorderColor[i]);
				style->getOption(m_sClassName + L".BackgroundColor[" + state + L"]", m_aBackgroundColor[i]);
				style->getOption(m_sClassName + L".BackgroundGradient[" + state + L"]", m_aBackgroundGradient[i]);
				style->getOption(m_sClassName + L".UpArrowBorderRadius[" + state + L"]", m_aUpArrowBorderRadius[i]);
				style->getOption(m_sClassName + L".UpArrowOuterBorderWidth[" + state + L"]", m_aUpArrowOuterBorderWidth[i]);
				style->getOption(m_sClassName + L".UpArrowInnerBorderWidth[" + state + L"]", m_aUpArrowInnerBorderWidth[i]);
				style->getOption(m_sClassName + L".UpArrowOuterBorderColor[" + state + L"]", m_aUpArrowOuterBorderColor[i]);
				style->getOption(m_sClassName + L".UpArrowInnerBorderColor[" + state + L"]", m_aUpArrowInnerBorderColor[i]);
				style->getOption(m_sClassName + L".UpArrowBackgroundColor[" + state + L"]", m_aUpArrowBackgroundColor[i]);
				style->getOption(m_sClassName + L".UpArrowBackgroundGradient[" + state + L"]", m_aUpArrowBackgroundGradient[i]);
				style->getOption(m_sClassName + L".UpArrowPadding[" + state + L"]", m_aUpArrowPadding[i]);
				style->getOption(m_sClassName + L".UpArrowColor1[" + state + L"]", m_aUpArrowColor1[i]);
				style->getOption(m_sClassName + L".UpArrowColor2[" + state + L"]", m_aUpArrowColor2[i]);
				style->getOption(m_sClassName + L".UpArrowColor3[" + state + L"]", m_aUpArrowColor3[i]);
				style->getOption(m_sClassName + L".DownArrowBorderRadius[" + state + L"]", m_aDownArrowBorderRadius[i]);
				style->getOption(m_sClassName + L".DownArrowOuterBorderWidth[" + state + L"]", m_aDownArrowOuterBorderWidth[i]);
				style->getOption(m_sClassName + L".DownArrowInnerBorderWidth[" + state + L"]", m_aDownArrowInnerBorderWidth[i]);
				style->getOption(m_sClassName + L".DownArrowOuterBorderColor[" + state + L"]", m_aDownArrowOuterBorderColor[i]);
				style->getOption(m_sClassName + L".DownArrowInnerBorderColor[" + state + L"]", m_aDownArrowInnerBorderColor[i]);
				style->getOption(m_sClassName + L".DownArrowBackgroundColor[" + state + L"]", m_aDownArrowBackgroundColor[i]);
				style->getOption(m_sClassName + L".DownArrowBackgroundGradient[" + state + L"]", m_aDownArrowBackgroundGradient[i]);
				style->getOption(m_sClassName + L".DownArrowPadding[" + state + L"]", m_aDownArrowPadding[i]);
				style->getOption(m_sClassName + L".DownArrowColor1[" + state + L"]", m_aDownArrowColor1[i]);
				style->getOption(m_sClassName + L".DownArrowColor2[" + state + L"]", m_aDownArrowColor2[i]);
				style->getOption(m_sClassName + L".DownArrowColor3[" + state + L"]", m_aDownArrowColor3[i]);
				style->getOption(m_sClassName + L".ArrowDistance[" + state + L"]", m_aArrowDistance[i]);
				style->getOption(m_sClassName + L".ArrowBorderRadius[" + state + L"]", m_aArrowBorderRadius[i]);
				style->getOption(m_sClassName + L".ArrowOuterBorderWidth[" + state + L"]", m_aArrowOuterBorderWidth[i]);
				style->getOption(m_sClassName + L".ArrowInnerBorderWidth[" + state + L"]", m_aArrowInnerBorderWidth[i]);
				style->getOption(m_sClassName + L".ArrowOuterBorderColor[" + state + L"]", m_aArrowOuterBorderColor[i]);
				style->getOption(m_sClassName + L".ArrowInnerBorderColor[" + state + L"]", m_aArrowInnerBorderColor[i]);
				style->getOption(m_sClassName + L".ArrowBackgroundColor[" + state + L"]", m_aArrowBackgroundColor[i]);
				style->getOption(m_sClassName + L".ArrowBackgroundGradient[" + state + L"]", m_aArrowBackgroundGradient[i]);
				style->getOption(m_sClassName + L".ArrowPadding[" + state + L"]", m_aArrowPadding[i]);
				style->getOption(m_sClassName + L".ArrowColor1[" + state + L"]", m_aArrowColor1[i]);
				style->getOption(m_sClassName + L".ArrowColor2[" + state + L"]", m_aArrowColor2[i]);
				style->getOption(m_sClassName + L".ArrowColor3[" + state + L"]", m_aArrowColor3[i]);
				style->getOption(m_sClassName + L".IconPadding[" + state + L"]", m_aIconPadding[i]);
				style->getOption(m_sClassName + L".ElementBackgroundColor[" + state + L"]", m_aElementBackgroundColor[i]);
				style->getOption(m_sClassName + L".ElementBackgroundGradient[" + state + L"]", m_aElementBackgroundGradient[i]);
				style->getOption(m_sClassName + L".ElementColor[" + state + L"]", m_aElementColor[i]);
				style->getOption(m_sClassName + L".ElementPadding[" + state + L"]", m_aElementPadding[i]);
			}
			m_bFirstDigit = true;
			getMonthCalendar()->UpdateFromStyle(style, m_sClassName + L".MonthCalendar");
			UpdateHoveredElement();
			m_bIgnoreGradient = false;
		}

		IBuiltInMonthCalendar *CDatePicker::getMonthCalendar()
		{
			if (!m_pMonthCalendar)
			{
				m_pMonthCalendar = new CBuiltIn(this);
				m_pMonthCalendar->setListener(&m_cListener);
			}
			return m_pMonthCalendar;
		}

		bool CDatePicker::UpdateHoveredElement()
		{
			if (getForm())
				return UpdateHoveredElement(FormToLocal((PointF)getForm()->ScreenToClient(Application->Mouse->getPosition())));
			return false;
		}

		bool CDatePicker::UpdateHoveredElement(const PointF &pos)
		{
			Element el{ Element::None };
			if (isEnabled(true))
			{
				State state{ getState() };
				if (m_eDisplayMode == DisplayMode::UpDown)
				{
					RectF arrows_rect{ getArrowsRect(state) };
					RectF r{ getUpArrowRect(arrows_rect, state) };
					if (pos.X >= r.Left && pos.X < r.Right && pos.Y >= r.Top && pos.Y < r.Bottom)
						el = Element::UpArrow;
					if (el == Element::None)
					{
						r = getDownArrowRect(arrows_rect, state);
						if (pos.X >= r.Left && pos.X < r.Right && pos.Y >= r.Top && pos.Y < r.Bottom)
							el = Element::DownArrow;
					}
				}
				else if (m_eDisplayMode == DisplayMode::DropDown)
				{
					RectF r{ getArrowRect(state) };
					if (pos.X >= r.Left && pos.X < r.Right && pos.Y >= r.Top && pos.Y < r.Bottom)
						el = Element::Arrow;
				}
				if (el == Element::None)
				{
					IPlatformFont *pf{ getFont()->getPlatformFont(getForm()->getRenderer()) };
					CONTENT content;
					if (CalculateContent(state, pf, getFont()->Distance, content) && pos.Y >= content.Rect.Top && pos.Y < content.Rect.Bottom)
					{
						if (pos.X >= content.Years.X && pos.X < content.Years.Y)
							el = Element::Years;
						if (el == Element::None && pos.X >= content.Months.X && pos.X < content.Months.Y)
							el = Element::Months;
						if (el == Element::None && pos.X >= content.Days.X && pos.X < content.Days.Y)
							el = Element::Days;
					}
				}
			}
			if (el != m_eHoveredElement)
			{
				m_eHoveredElement = el;
				return true;
			}
			return false;
		}

		RectF CDatePicker::getArrowsRect(const State state)
		{
			float w{ getHeight() - m_aOuterBorderWidth[(int)state].Top - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Top - m_aInnerBorderWidth[(int)state].Bottom };
			RectF result;
			result.Top = m_aOuterBorderWidth[(int)state].Top + m_aInnerBorderWidth[(int)state].Top;
			result.Bottom = getHeight() - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Bottom;
			if (m_bArrowsAtRight)
			{
				result.Right = getWidth() - m_aOuterBorderWidth[(int)state].Right - m_aInnerBorderWidth[(int)state].Right;
				result.Left = result.Right - w;
			}
			else
			{
				result.Left = m_aOuterBorderWidth[(int)state].Left + m_aInnerBorderWidth[(int)state].Left;
				result.Right = result.Left + w;
			}
			if (result.has_negative() || result.is_zero() || result.Right >= getWidth() || result.Bottom >= getHeight())
				return RectF{ 0, 0, 0, 0 };
			return result;
		}

		RectF CDatePicker::getUpArrowRect(const RectF &rect, const State state)
		{
			if (rect.is_zero())
				return RectF{ 0, 0, 0, 0 };
			RectF result{ rect.Left, rect.Top, rect.Right, rect.Top + (rect.height() - m_aArrowDistance[(int)state]) * 0.5f };
			if (!result.is_valid())
				return RectF{ 0, 0, 0, 0 };
			return result;
		}

		RectF CDatePicker::getDownArrowRect(const RectF &rect, const State state)
		{
			if (rect.is_zero())
				return RectF{ 0, 0, 0, 0 };
			RectF result{ rect.Left, rect.Top + (rect.height() - m_aArrowDistance[(int)state]) * 0.5f + m_aArrowDistance[(int)state], rect.Right, rect.Bottom };
			if (!result.is_valid())
				return RectF{ 0, 0, 0, 0 };
			return result;
		}

		RectF CDatePicker::getArrowRect(const State state)
		{
			float w{ getHeight() - m_aOuterBorderWidth[(int)state].Top - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Top - m_aInnerBorderWidth[(int)state].Bottom };
			if (m_bShowIcon)
				w *= 2;
			RectF result;
			result.Top = m_aOuterBorderWidth[(int)state].Top + m_aInnerBorderWidth[(int)state].Top;
			result.Bottom = getHeight() - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Bottom;
			if (m_bArrowsAtRight)
			{
				result.Right = getWidth() - m_aOuterBorderWidth[(int)state].Right - m_aInnerBorderWidth[(int)state].Right;
				result.Left = result.Right - w;
			}
			else
			{
				result.Left = m_aOuterBorderWidth[(int)state].Left + m_aInnerBorderWidth[(int)state].Left;
				result.Right = result.Left + w;
			}
			if (result.has_negative() || result.is_zero() || result.Right >= getWidth() || result.Bottom >= getHeight())
				return RectF{ 0, 0, 0, 0 };
			return result;
		}

		String CDatePicker::getContentDay()
		{
			if (m_bShowDayLeadingZeros && getMonthCalendar()->getDay() < 10)
				return L"0" + ToString(getMonthCalendar()->getDay());
			return ToString(getMonthCalendar()->getDay());
		}

		String CDatePicker::getContentMonth()
		{
			switch (m_eMonthFormat)
			{
			case MonthFormat::Medium:
				return CTranslate::Month(months::ShortNames[getMonthCalendar()->getMonth() - 1]);
			case MonthFormat::Long:
				return CTranslate::Month(months::Names[getMonthCalendar()->getMonth() - 1]);
			default:
				if (m_bShowMonthLeadingZeros && getMonthCalendar()->getMonth() < 10)
					return L"0" + ToString(getMonthCalendar()->getMonth());
				return ToString(getMonthCalendar()->getMonth());
			}
		}

		String CDatePicker::getContentYear()
		{
			if (m_bShowYearLeadingZeros)
			{
				if (ntl::Abs<int>(getMonthCalendar()->getYear()) < 10)
					return String(getMonthCalendar()->getYear() < 0 ? L"-" : L"") + L"000" + ToString(ntl::Abs<int>(getMonthCalendar()->getYear()));
				if (ntl::Abs<int>(getMonthCalendar()->getYear()) < 100)
					return String(getMonthCalendar()->getYear() < 0 ? L"-" : L"") + L"00" + ToString(ntl::Abs<int>(getMonthCalendar()->getYear()));
				if (ntl::Abs<int>(getMonthCalendar()->getYear()) < 1000)
					return String(getMonthCalendar()->getYear() < 0 ? L"-" : L"") + L"0" + ToString(ntl::Abs<int>(getMonthCalendar()->getYear()));
			}
			return ToString(getMonthCalendar()->getYear());
		}

		bool CDatePicker::CalculateContent(const State state, IPlatformFont *pf, const float distance, CONTENT &content)
		{
			if (pf)
			{
				// Line height and part widths
				content.LineHeight = pf->getStringSize(L"Wy", 0).Y;
				content.ContentDay = getContentDay();
				content.ContentMonth = getContentMonth();
				content.ContentYear = getContentYear();
				float w_days{ pf->getStringSize(content.ContentDay, distance).X };
				float w_months{ pf->getStringSize(content.ContentMonth, distance).X };
				float w_years{ pf->getStringSize(content.ContentYear, distance).X };
				float w_separator1{ m_sSeparator1.empty() ? 0 : pf->getStringSize(m_sSeparator1, distance).X };
				float w_separator2{ m_sSeparator2.empty() ? 0 : pf->getStringSize(m_sSeparator2, distance).X };
				// Content rect
				content.Rect.Left = m_aOuterBorderWidth[(int)state].Left + m_aInnerBorderWidth[(int)state].Left;
				content.Rect.Right = getWidth() - m_aOuterBorderWidth[(int)state].Right - m_aInnerBorderWidth[(int)state].Right;
				switch (m_eDisplayMode)
				{
				case DisplayMode::UpDown:
					if (m_bArrowsAtRight)
						content.Rect.Right -= getHeight() - m_aOuterBorderWidth[(int)state].Top - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Top - m_aInnerBorderWidth[(int)state].Bottom;
					else
						content.Rect.Left += getHeight() - m_aOuterBorderWidth[(int)state].Top - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Top - m_aInnerBorderWidth[(int)state].Bottom;
					break;
				case DisplayMode::DropDown:
					if (m_bShowIcon)
					{
						if (m_bArrowsAtRight)
							content.Rect.Right -= 2 * (getHeight() - m_aOuterBorderWidth[(int)state].Top - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Top - m_aInnerBorderWidth[(int)state].Bottom);
						else
							content.Rect.Left += 2 * (getHeight() - m_aOuterBorderWidth[(int)state].Top - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Top - m_aInnerBorderWidth[(int)state].Bottom);
					}
					else
					{
						if (m_bArrowsAtRight)
							content.Rect.Right -= getHeight() - m_aOuterBorderWidth[(int)state].Top - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Top - m_aInnerBorderWidth[(int)state].Bottom;
						else
							content.Rect.Left += getHeight() - m_aOuterBorderWidth[(int)state].Top - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Top - m_aInnerBorderWidth[(int)state].Bottom;
					}
					break;
				default:
					break;
				}
				content.Rect.Top = m_aOuterBorderWidth[(int)state].Top + m_aInnerBorderWidth[(int)state].Top;
				content.Rect.Bottom = getHeight() - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Bottom;
				content.Rect.Top = (content.Rect.Top + content.Rect.Bottom - content.LineHeight) * 0.5f;
				content.Rect.Bottom = content.Rect.Top + content.LineHeight;
				float w{ w_days + w_months + w_years + 2 * distance + (w_separator1 > 0 ? (w_separator1 + distance) : 0) + (w_separator2 > 0 ? (w_separator2 + distance) : 0) };
				switch (m_eContentAlign)
				{
				case TextAlign::Right:
					content.Rect.Right -= m_aElementPadding[(int)state];
					content.Rect.Left = content.Rect.Right - w;
					break;
				case TextAlign::Center:
					content.Rect.Left = (content.Rect.Left + content.Rect.Right - w) * 0.5f;
					content.Rect.Right = content.Rect.Left + w;
					break;
				default:
					content.Rect.Left += m_aElementPadding[(int)state];
					content.Rect.Right = content.Rect.Left + w;
				}
				if (!content.Rect.is_valid() || content.Rect.has_negative() || content.Rect.is_zero() || content.Rect.Left >= getWidth() || content.Rect.Right >= getWidth() || content.Rect.Bottom >= getHeight())
					return false;
				switch (m_eElementOrder)
				{
				case ElementOrder::DayMonthYear:
					content.Days = PointF{ std::round(content.Rect.Left), std::round(content.Rect.Left + w_days + distance) };
					content.Separator1 = PointF{ content.Days.Y, std::round(content.Days.Y + w_separator1 + (w_separator1 > 0 ? distance : 0)) };
					content.Months = PointF{ content.Separator1.Y, std::round(content.Separator1.Y + w_months + distance) };
					content.Separator2 = PointF{ content.Months.Y, std::round(content.Months.Y + w_separator2 + (w_separator2 > 0 ? distance : 0)) };
					content.Years = PointF{ content.Separator2.Y, std::round(content.Separator2.Y+ w_years) };
					break;
				case ElementOrder::DayYearMonth:
					content.Days = PointF{ std::round(content.Rect.Left), std::round(content.Rect.Left + w_days + distance) };
					content.Separator1 = PointF{ content.Days.Y, std::round(content.Days.Y + w_separator1 + (w_separator1 > 0 ? distance : 0)) };
					content.Years = PointF{ content.Separator1.Y, std::round(content.Separator1.Y + w_years + distance) };
					content.Separator2 = PointF{ content.Years.Y, std::round(content.Years.Y + w_separator2 + (w_separator2 > 0 ? distance : 0)) };
					content.Months = PointF{ content.Separator2.Y, std::round(content.Separator2.Y + w_months) };
					break;
				case ElementOrder::MonthDayYear:
					content.Months = PointF{ std::round(content.Rect.Left), std::round(content.Rect.Left + w_months + distance) };
					content.Separator1 = PointF{ content.Months.Y, std::round(content.Months.Y + w_separator1 + (w_separator1 > 0 ? distance : 0)) };
					content.Days = PointF{ content.Separator1.Y, std::round(content.Separator1.Y + w_days + distance) };
					content.Separator2 = PointF{ content.Days.Y, std::round(content.Days.Y + w_separator2 + (w_separator2 > 0 ? distance : 0)) };
					content.Years = PointF{ content.Separator2.Y, std::round(content.Separator2.Y + w_years) };
					break;
				case ElementOrder::MonthYearDay:
					content.Months = PointF{ std::round(content.Rect.Left), std::round(content.Rect.Left + w_months + distance) };
					content.Separator1 = PointF{ content.Months.Y, std::round(content.Months.Y + w_separator1 + (w_separator1 > 0 ? distance : 0)) };
					content.Years = PointF{ content.Separator1.Y, std::round(content.Separator1.Y + w_years + distance) };
					content.Separator2 = PointF{ content.Years.Y, std::round(content.Years.Y + w_separator2 + (w_separator2 > 0 ? distance : 0)) };
					content.Days = PointF{ content.Separator2.Y, std::round(content.Separator2.Y + w_days) };
					break;
				case ElementOrder::YearDayMonth:
					content.Years = PointF{ std::round(content.Rect.Left), std::round(content.Rect.Left + w_years + distance) };
					content.Separator1 = PointF{ content.Years.Y, std::round(content.Years.Y + w_separator1 + (w_separator1 > 0 ? distance : 0)) };
					content.Days = PointF{ content.Separator1.Y, std::round(content.Separator1.Y + w_days + distance) };
					content.Separator2 = PointF{ content.Days.Y, std::round(content.Days.Y + w_separator2 + (w_separator2 > 0 ? distance : 0)) };
					content.Months = PointF{ content.Separator2.Y, std::round(content.Separator2.Y + w_months) };
					break;
				case ElementOrder::YearMonthDay:
					content.Years = PointF{ std::round(content.Rect.Left), std::round(content.Rect.Left + w_years + distance) };
					content.Separator1 = PointF{ content.Years.Y, std::round(content.Years.Y + w_separator1 + (w_separator1 > 0 ? distance : 0)) };
					content.Months = PointF{ content.Separator1.Y, std::round(content.Separator1.Y + w_months + distance) };
					content.Separator2 = PointF{ content.Months.Y, std::round(content.Months.Y + w_separator2 + (w_separator2 > 0 ? distance : 0)) };
					content.Days = PointF{ content.Separator2.Y, std::round(content.Separator2.Y + w_days) };
					break;
				}
				return true;
			}
			return false;
		}

		CDatePicker::State CDatePicker::getUpArrowState()
		{
			if (!isEnabled(false))
				return State::Disabled;
			if (m_eDownElement == Element::UpArrow)
			{
				if (m_eHoveredElement == Element::UpArrow)
					return State::ActiveHovered;
				return State::Active;
			}
			if (isFocused())
			{
				if (m_eHoveredElement == Element::UpArrow)
					return State::FocusedHovered;
				return State::Focused;
			}
			if (m_eHoveredElement == Element::UpArrow)
				return State::Hovered;
			return State::Normal;
		}

		CDatePicker::State CDatePicker::getDownArrowState()
		{
			if (!isEnabled(false))
				return State::Disabled;
			if (m_eDownElement == Element::DownArrow)
			{
				if (m_eHoveredElement == Element::DownArrow)
					return State::ActiveHovered;
				return State::Active;
			}
			if (isFocused())
			{
				if (m_eHoveredElement == Element::DownArrow)
					return State::FocusedHovered;
				return State::Focused;
			}
			if (m_eHoveredElement == Element::DownArrow)
				return State::Hovered;
			return State::Normal;
		}

		CDatePicker::State CDatePicker::getArrowState()
		{
			if (!isEnabled(false))
				return State::Disabled;
			if (m_bOpened)
			{
				if (m_eHoveredElement == Element::Arrow)
					return State::ActiveHovered;
				return State::Active;
			}
			if (isFocused())
			{
				if (m_eHoveredElement == Element::Arrow)
					return State::FocusedHovered;
				return State::Focused;
			}
			if (m_eHoveredElement == Element::Arrow)
				return State::Hovered;
			return State::Normal;
		}

		CDatePicker::State CDatePicker::getYearsState()
		{
			if (!isEnabled(false))
				return State::Disabled;
			if (isFocused())
			{
				if (m_eActiveElement == Element::Years)
				{
					if (m_eHoveredElement == Element::Years)
						return State::ActiveHovered;
					return State::Active;
				}
				if (m_eHoveredElement == Element::Years)
					return State::FocusedHovered;
				return State::Focused;
			}
			if (m_eHoveredElement == Element::Years)
				return State::Hovered;
			return State::Normal;
		}

		CDatePicker::State CDatePicker::getMonthsState()
		{
			if (!isEnabled(false))
				return State::Disabled;
			if (isFocused())
			{
				if (m_eActiveElement == Element::Months)
				{
					if (m_eHoveredElement == Element::Months)
						return State::ActiveHovered;
					return State::Active;
				}
				if (m_eHoveredElement == Element::Months)
					return State::FocusedHovered;
				return State::Focused;
			}
			if (m_eHoveredElement == Element::Months)
				return State::Hovered;
			return State::Normal;
		}

		CDatePicker::State CDatePicker::getDaysState()
		{
			if (!isEnabled(false))
				return State::Disabled;
			if (isFocused())
			{
				if (m_eActiveElement == Element::Days)
				{
					if (m_eHoveredElement == Element::Days)
						return State::ActiveHovered;
					return State::Active;
				}
				if (m_eHoveredElement == Element::Days)
					return State::FocusedHovered;
				return State::Focused;
			}
			if (m_eHoveredElement == Element::Days)
				return State::Hovered;
			return State::Normal;
		}

		Color CDatePicker::CalculateElementColor(const State state)
		{
			if (m_aElementColor[(int)state].A > 0)
				return m_aElementColor[(int)state];
			return getFont()->Color;
		}

		RectF CDatePicker::CalculateClientRect(const State state)
		{
			RectF result{
				m_aOuterBorderWidth[(int)state].Left + m_aInnerBorderWidth[(int)state].Left,
				m_aOuterBorderWidth[(int)state].Top + m_aInnerBorderWidth[(int)state].Top,
				getWidth() - m_aOuterBorderWidth[(int)state].Right - m_aInnerBorderWidth[(int)state].Right,
				getHeight() - m_aOuterBorderWidth[(int)state].Bottom - m_aInnerBorderWidth[(int)state].Bottom
			};
			result.validate();
			return result;
		}

		CDatePicker::Element CDatePicker::getNextElement() const
		{
			switch (m_eActiveElement)
			{
			case Element::Years:
				switch (m_eElementOrder)
				{
				case ElementOrder::DayYearMonth:
				case ElementOrder::YearMonthDay:
					return Element::Months;
				case ElementOrder::MonthYearDay:
				case ElementOrder::YearDayMonth:
					return Element::Days;
				default:
					break;
				}
				break;
			case Element::Months:
				switch (m_eElementOrder)
				{
				case ElementOrder::DayMonthYear:
				case ElementOrder::MonthYearDay:
					return Element::Years;
				case ElementOrder::MonthDayYear:
				case ElementOrder::YearMonthDay:
					return Element::Days;
				default:
					break;
				}
				break;
			case Element::Days:
				switch (m_eElementOrder)
				{
				case ElementOrder::DayMonthYear:
				case ElementOrder::YearDayMonth:
					return Element::Months;
				case ElementOrder::DayYearMonth:
				case ElementOrder::MonthDayYear:
					return Element::Years;
				default:
					break;
				}
				break;
			default:
				break;
			}
			return m_eActiveElement;
		}

		CDatePicker::Element CDatePicker::getPrevElement() const
		{
			switch (m_eActiveElement)
			{
			case Element::Years:
				switch (m_eElementOrder)
				{
				case ElementOrder::DayMonthYear:
				case ElementOrder::MonthYearDay:
					return Element::Months;
				case ElementOrder::DayYearMonth:
				case ElementOrder::MonthDayYear:
					return Element::Days;
				default:
					break;
				}
				break;
			case Element::Months:
				switch (m_eElementOrder)
				{
				case ElementOrder::DayMonthYear:
				case ElementOrder::YearDayMonth:
					return Element::Days;
				case ElementOrder::DayYearMonth:
				case ElementOrder::YearMonthDay:
					return Element::Years;
				default:
					break;
				}
				break;
			case Element::Days:
				switch (m_eElementOrder)
				{
				case ElementOrder::MonthDayYear:
				case ElementOrder::YearMonthDay:
					return Element::Months;
				case ElementOrder::MonthYearDay:
				case ElementOrder::YearDayMonth:
					return Element::Years;
				default:
					break;
				}
				break;
			default:
				break;
			}
			return m_eActiveElement;
		}
	#pragma endregion

	#pragma region Paint
		void CDatePicker::RenderControl()
		{
			IRenderer *renderer{ getForm()->getRenderer() };
			State state{ getState() };
			PointF disp{ DispOnCanvas(m_aShadowColor[(int)state], m_aShadowShift[(int)state], m_aShadowRadius[(int)state]) };
			RectF all_rect{ AddShadow(RectF{ 0, 0, getWidth(), getHeight() }, m_aShadowColor[(int)state], m_aShadowShift[(int)state], m_aShadowRadius[(int)state]) };
			if (PrepareCanvas(renderer, &m_pCanvas, all_rect))
			{
				CStoreTarget s_target{ renderer };
				renderer
					->ActivateTarget(m_pCanvas)
					->Clear(Color{ 0, 0, 0, 0 });

				RectF rect{ disp.X, disp.Y, disp.X + getWidth(), disp.Y + getHeight() };

				DrawBlockShadow(
					renderer,
					rect,
					m_aBorderRadius[(int)state],
					m_aShadowColor[(int)state],
					m_aShadowShift[(int)state],
					m_aShadowRadius[(int)state]);
				DrawDoubleBackground(
					renderer,
					rect,
					m_aOuterBorderWidth[(int)state],
					m_aInnerBorderWidth[(int)state],
					m_aBorderRadius[(int)state],
					m_aOuterBorderColor[(int)state],
					m_aInnerBorderColor[(int)state],
					m_aBackgroundColor[(int)state],
					m_aBackgroundGradient[(int)state]);

				RectF client{ CalculateClientRect(state) };
				if (!client.is_zero())
				{
					ITexture *clip{ renderer->CreateTexture(ntl::Round<int>(client.width()), ntl::Round<int>(client.height()), 1, TextureFormat::RGBA, true) };
					if (clip)
					{
						renderer
							->ActivateTarget(clip)
							->Clear(Color{ 0, 0, 0, 0 });
						RenderContent(renderer, state, PointF{ -client.Left, -client.Top });
						RenderArrows(renderer, state, PointF{ -client.Left, -client.Top });
						CStorePrimitiveMatrix s_matrix{ renderer };
						renderer->ActivateTarget(m_pCanvas);
						if (m_aBorderRadius[(int)state].has_positive())
						{
							CStoreBlock s_block{ renderer };
							Block b{ rect - disp, AddElements(m_aOuterBorderWidth[(int)state], m_aInnerBorderWidth[(int)state]), m_aBorderRadius[(int)state], PointLocation::Inside };
							renderer
								->ActivateBlock(&b)
								->ActivatePrimitiveMatrix(ntl::Mat4Translate<float>(client.Left + disp.X, client.Top + disp.Y, 0))
								->DrawImage(clip, 1);
						}
						else
						{
							renderer
								->ActivatePrimitiveMatrix(ntl::Mat4Translate<float>(client.Left + disp.X, client.Top + disp.Y, 0))
								->DrawImage(clip, 1);
						}
						clip->Release();
					}
				}
				m_pCanvas->setValid(true);
			}
			DrawCanvas(renderer, getTransformMatrix(), m_pCanvas, disp);
		}

		void CDatePicker::RenderContent(IRenderer *renderer, const State state, const PointF &disp)
		{
			IPlatformFont *pf{ getFont()->getPlatformFont(renderer) };
			float distance{ getFont()->Distance };
			CONTENT content;
			if (CalculateContent(state, pf, distance, content))
			{
				// Days
				State st{ getDaysState() };
				if (m_aElementBackgroundGradient[(int)st].getPointCount() >= 2)
					renderer->DrawGradient(RectF{ content.Days.X, content.Rect.Top, content.Days.Y, content.Rect.Bottom } + disp, m_aElementBackgroundGradient[(int)st]);
				else if (m_aElementBackgroundColor[(int)st].A > 0)
					renderer->DrawRectangle(RectF{ content.Days.X, content.Rect.Top, content.Days.Y, content.Rect.Bottom } + disp, m_aElementBackgroundColor[(int)st]);
				Color c{ CalculateElementColor(st) };
				if (c.A > 0)
				{
					CStorePrimitiveMatrix s_matrix{ renderer };
					PointF p{ PointF{ content.Days.X, content.Rect.Top } + disp };
					renderer
						->ActivatePrimitiveMatrix(ntl::Mat4Translate<float>(p.X, p.Y, 0))
						->DrawText(content.ContentDay, pf, distance, c);
				}

				// Months
				st = getMonthsState();
				if (m_aElementBackgroundGradient[(int)st].getPointCount() >= 2)
					renderer->DrawGradient(RectF{ content.Months.X, content.Rect.Top, content.Months.Y, content.Rect.Bottom } + disp, m_aElementBackgroundGradient[(int)st]);
				else if (m_aElementBackgroundColor[(int)st].A > 0)
					renderer->DrawRectangle(RectF{ content.Months.X, content.Rect.Top, content.Months.Y, content.Rect.Bottom } + disp, m_aElementBackgroundColor[(int)st]);
				c = CalculateElementColor(st);
				if (c.A > 0)
				{
					CStorePrimitiveMatrix s_matrix{ renderer };
					PointF p{ PointF{ content.Months.X, content.Rect.Top } + disp };
					renderer
						->ActivatePrimitiveMatrix(ntl::Mat4Translate<float>(p.X, p.Y, 0))
						->DrawText(content.ContentMonth, pf, distance, c);
				}

				// Years
				st = getYearsState();
				if (m_aElementBackgroundGradient[(int)st].getPointCount() >= 2)
					renderer->DrawGradient(RectF{ content.Years.X, content.Rect.Top, content.Years.Y, content.Rect.Bottom } + disp, m_aElementBackgroundGradient[(int)st]);
				else if (m_aElementBackgroundColor[(int)st].A > 0)
					renderer->DrawRectangle(RectF{ content.Years.X, content.Rect.Top, content.Years.Y, content.Rect.Bottom } + disp, m_aElementBackgroundColor[(int)st]);
				c = CalculateElementColor(st);
				if (c.A > 0)
				{
					CStorePrimitiveMatrix s_matrix{ renderer };
					PointF p{ PointF{ content.Years.X, content.Rect.Top } + disp };
					renderer
						->ActivatePrimitiveMatrix(ntl::Mat4Translate<float>(p.X, p.Y, 0))
						->DrawText(content.ContentYear, pf, distance, c);
				}
				
				// Separators
				if (getFont()->Color.A > 0)
				{
					CStorePrimitiveMatrix s_matrix{ renderer };
					if (!m_sSeparator1.empty())
					{
						PointF p{ PointF{ content.Separator1.X, content.Rect.Top } + disp };
						renderer
							->ActivatePrimitiveMatrix(ntl::Mat4Translate<float>(p.X, p.Y, 0))
							->DrawText(m_sSeparator1, pf, 0, getFont()->Color);
					}
					if (!m_sSeparator2.empty())
					{
						PointF p{ PointF{ content.Separator2.X, content.Rect.Top } + disp };
						renderer
							->ActivatePrimitiveMatrix(ntl::Mat4Translate<float>(p.X, p.Y, 0))
							->DrawText(m_sSeparator2, pf, 0, getFont()->Color);
					}
				}
			}
		}

		void CDatePicker::RenderArrows(IRenderer *renderer, const State state, const PointF &disp)
		{
			if (m_eDisplayMode == DisplayMode::UpDown)
			{
				RectF arrows_rect{ getArrowsRect(state) };
				if (!arrows_rect.is_zero())
				{
					// Up arrow
					RectF r{ getUpArrowRect(arrows_rect, state) + disp };
					if (!r.is_zero())
					{
						State st{ getUpArrowState() };
						DrawDoubleBackground(
							renderer,
							r,
							m_aUpArrowOuterBorderWidth[(int)st],
							m_aUpArrowInnerBorderWidth[(int)st],
							m_aUpArrowBorderRadius[(int)st],
							m_aUpArrowOuterBorderColor[(int)st],
							m_aUpArrowInnerBorderColor[(int)st],
							m_aUpArrowBackgroundColor[(int)st],
							m_aUpArrowBackgroundGradient[(int)st]);
						r.Left += m_aUpArrowOuterBorderWidth[(int)st].Left + m_aUpArrowInnerBorderWidth[(int)st].Left + m_aUpArrowPadding[(int)st].Left;
						r.Top += m_aUpArrowOuterBorderWidth[(int)st].Top + m_aUpArrowInnerBorderWidth[(int)st].Top + m_aUpArrowPadding[(int)st].Top;
						r.Right -= m_aUpArrowOuterBorderWidth[(int)st].Right + m_aUpArrowInnerBorderWidth[(int)st].Right + m_aUpArrowPadding[(int)st].Right;
						r.Bottom -= m_aUpArrowOuterBorderWidth[(int)st].Bottom + m_aUpArrowInnerBorderWidth[(int)st].Bottom + m_aUpArrowPadding[(int)st].Bottom;
						if (r.is_valid() && !r.is_zero())
						{
							if (m_aUpArrowColor1[(int)st].A > 0 || m_aUpArrowColor2[(int)st].A > 0 || m_aUpArrowColor3[(int)st].A > 0)
							{
								renderer->DrawTriangle(
									PointF{ r.Left, r.Bottom },
									PointF{ (r.Left + r.Right) * 0.5f, r.Top },
									PointF{ r.Right, r.Bottom },
									m_aUpArrowColor1[(int)st],
									m_aUpArrowColor2[(int)st],
									m_aUpArrowColor3[(int)st]);
							}
						}
					}
					// Down arrow
					r = getDownArrowRect(arrows_rect, state) + disp;
					if (!r.is_zero())
					{
						State st{ getDownArrowState() };
						DrawDoubleBackground(
							renderer,
							r,
							m_aDownArrowOuterBorderWidth[(int)st],
							m_aDownArrowInnerBorderWidth[(int)st],
							m_aDownArrowBorderRadius[(int)st],
							m_aDownArrowOuterBorderColor[(int)st],
							m_aDownArrowInnerBorderColor[(int)st],
							m_aDownArrowBackgroundColor[(int)st],
							m_aDownArrowBackgroundGradient[(int)st]);
						r.Left += m_aDownArrowOuterBorderWidth[(int)st].Left + m_aDownArrowInnerBorderWidth[(int)st].Left + m_aDownArrowPadding[(int)st].Left;
						r.Top += m_aDownArrowOuterBorderWidth[(int)st].Top + m_aDownArrowInnerBorderWidth[(int)st].Top + m_aDownArrowPadding[(int)st].Top;
						r.Right -= m_aDownArrowOuterBorderWidth[(int)st].Right + m_aDownArrowInnerBorderWidth[(int)st].Right + m_aDownArrowPadding[(int)st].Right;
						r.Bottom -= m_aDownArrowOuterBorderWidth[(int)st].Bottom + m_aDownArrowInnerBorderWidth[(int)st].Bottom + m_aDownArrowPadding[(int)st].Bottom;
						if (r.is_valid() && !r.is_zero())
						{
							if (m_aDownArrowColor1[(int)st].A > 0 || m_aDownArrowColor2[(int)st].A > 0 || m_aDownArrowColor3[(int)st].A > 0)
							{
								renderer->DrawTriangle(
									PointF{ r.Right, r.Top },
									PointF{ (r.Left + r.Right) * 0.5f, r.Bottom },
									PointF{ r.Left, r.Top },
									m_aDownArrowColor1[(int)st],
									m_aDownArrowColor2[(int)st],
									m_aDownArrowColor3[(int)st]);
							}
						}
					}
				}
			}
			else if (m_eDisplayMode == DisplayMode::DropDown)
			{
				RectF r{ getArrowRect(state) + disp };
				if (!r.is_zero())
				{
					State st{ getArrowState() };
					DrawDoubleBackground(
						renderer,
						r,
						m_aArrowOuterBorderWidth[(int)st],
						m_aArrowInnerBorderWidth[(int)st],
						m_aArrowBorderRadius[(int)st],
						m_aArrowOuterBorderColor[(int)st],
						m_aArrowInnerBorderColor[(int)st],
						m_aArrowBackgroundColor[(int)st],
						m_aArrowBackgroundGradient[(int)st]);
					RectF r_arrow, r_icon;
					if (m_bShowIcon)
					{
						if (m_bArrowsAtRight)
						{
							r_arrow.Left = (r.Left + r.Right) * 0.5f;
							r_arrow.Top = r.Top;
							r_arrow.Right = r.Right;
							r_arrow.Bottom = r.Bottom;
							r_icon = RectF{ r.Left, r.Top, r_arrow.Left, r.Bottom };
						}
						else
						{
							r_arrow.Left = r.Left;
							r_arrow.Top = r.Top;
							r_arrow.Right = (r.Left + r.Right) * 0.5f;
							r_arrow.Bottom = r.Bottom;
							r_icon = RectF{ r_arrow.Right, r.Top, r.Right, r.Bottom };
						}
					}
					else
					{
						r_arrow = r;
						r_icon = RectF{ 0, 0, 0, 0 };
					}
					r_arrow.Left += m_aArrowOuterBorderWidth[(int)st].Left + m_aArrowInnerBorderWidth[(int)st].Left + m_aArrowPadding[(int)st].Left;
					r_arrow.Top += m_aArrowOuterBorderWidth[(int)st].Top + m_aArrowInnerBorderWidth[(int)st].Top + m_aArrowPadding[(int)st].Top;
					r_arrow.Right -= m_aArrowOuterBorderWidth[(int)st].Right + m_aArrowInnerBorderWidth[(int)st].Right + m_aArrowPadding[(int)st].Right;
					r_arrow.Bottom-= m_aArrowOuterBorderWidth[(int)st].Bottom + m_aArrowInnerBorderWidth[(int)st].Bottom + m_aArrowPadding[(int)st].Bottom;
					if ((r_arrow.is_valid() && !r_arrow.is_zero()) && (m_aArrowColor1[(int)st].A > 0 || m_aArrowColor2[(int)st].A > 0 || m_aArrowColor3[(int)st].A > 0))
					{
						renderer->DrawTriangle(
							PointF{ r_arrow.Right, r_arrow.Top },
							PointF{ (r_arrow.Left + r_arrow.Right) * 0.5f, r_arrow.Bottom },
							PointF{ r_arrow.Left, r_arrow.Top },
							m_aArrowColor1[(int)st],
							m_aArrowColor2[(int)st],
							m_aArrowColor3[(int)st]);
					}
					if (r_icon.width() > 0)
					{
						r_icon.Left += m_aArrowOuterBorderWidth[(int)st].Left + m_aArrowInnerBorderWidth[(int)st].Left + m_aIconPadding[(int)st].Left;
						r_icon.Top += m_aArrowOuterBorderWidth[(int)st].Top + m_aArrowInnerBorderWidth[(int)st].Top + m_aIconPadding[(int)st].Top;
						r_icon.Right -= m_aArrowOuterBorderWidth[(int)st].Right + m_aArrowInnerBorderWidth[(int)st].Right + m_aIconPadding[(int)st].Right;
						r_icon.Bottom -= m_aArrowOuterBorderWidth[(int)st].Bottom + m_aArrowInnerBorderWidth[(int)st].Bottom + m_aIconPadding[(int)st].Bottom;
						if (r_icon.is_valid() && !r_icon.is_zero())
						{
							ITexture *icon{ (m_pImageList && m_aIconIndex[(int)st] >= 0) ? m_pImageList->getTexture(m_aIconIndex[(int)st]) : nullptr };
							if (!icon)
								icon = renderer->CreateTextureFromImage(m_cIcon, 1, TextureFormat::RGBA, true);
							if (icon)
							{
								float scale{ ntl::Min<float>(r_icon.width() / icon->Widthf, r_icon.height() / icon->Heightf) };
								CStorePrimitiveMatrix s_matrix{ renderer };
								renderer
									->ActivatePrimitiveMatrix(ntl::Mat4Translate<float>(r_icon.Left, r_icon.Top, 0) * ((scale < 1) ? ntl::Mat4Scale<float>(scale, scale, 1) : Identity))
									->DrawImage(icon, 1);
							}
						}
					}
				}
			}
		}

		void CDatePicker::RenderCalendar()
		{
			if (m_bOpened)
			{
				IRenderer *renderer{ getForm()->getRenderer() };
				PointF disp{ DispOnCanvas(m_sCalendarShadowColor, m_sCalendarShadowShift, m_iCalendarShadowRadius) };
				if (!m_pCanvasCalendar || !m_pCanvasCalendar->isValid() || getMonthCalendar()->isAnimating())
				{
					RectF all_rect{ AddShadow(RectF{ 0, 0, m_sCalendarRect.width(), m_sCalendarRect.height() }, m_sCalendarShadowColor, m_sCalendarShadowShift, m_iCalendarShadowRadius) };
					if (!m_pCanvasCalendar)
						m_pCanvasCalendar = renderer->CreateTexture(ntl::Round<int>(all_rect.width()), ntl::Round<int>(all_rect.height()), 1, TextureFormat::RGBA, true);
					else
						m_pCanvasCalendar->setSize(ntl::Round<int>(all_rect.width()), ntl::Round<int>(all_rect.height()));
					if (m_pCanvasCalendar)
					{
						CStoreTarget s_target{ renderer };
						renderer
							->ActivateTarget(m_pCanvasCalendar)
							->Clear(Color{ 0, 0, 0, 0 });

						RectF rect{ disp.X, disp.Y, disp.X + m_sCalendarRect.width(), disp.Y + m_sCalendarRect.height() };

						DrawBlockShadow(
							renderer,
							rect,
							m_sCalendarBorderRadius,
							m_sCalendarShadowColor,
							m_sCalendarShadowShift,
							m_iCalendarShadowRadius);
						DrawDoubleBackground(
							renderer,
							rect,
							m_sCalendarOuterBorderWidth,
							m_sCalendarInnerBorderWidth,
							m_sCalendarBorderRadius,
							m_sCalendarOuterBorderColor,
							m_sCalendarInnerBorderColor,
							m_sCalendarBackgroundColor,
							m_cCalendarBackgroundGradient);

						Mat4f t;
						ntl::Translate<float>(t, getMonthCalendar()->getLeft(), getMonthCalendar()->getTop(), 0);
						if (m_sCalendarBorderRadius.has_positive() || m_sCalendarInnerBorderWidth.has_positive() || m_sCalendarOuterBorderWidth.has_positive())
						{
							Block b{ rect, AddElements(m_sCalendarOuterBorderWidth, m_sCalendarInnerBorderWidth, m_sCalendarPadding), m_sCalendarBorderRadius, PointLocation::Inside };
							getMonthCalendar()->Render(false, t, &b);
						}
						else
							getMonthCalendar()->Render(false, t, nullptr);

						m_pCanvasCalendar->setValid(true);
					}
				}
				DrawCanvas(renderer, getTransformMatrix() * ntl::Mat4Translate<float>(m_sCalendarRect.Left, m_sCalendarRect.Top, 0), m_pCanvasCalendar, disp);
			}
		}
	#pragma endregion
	}
}